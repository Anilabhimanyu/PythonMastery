<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphs - Complete Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            padding: 20px;
            line-height: 1.7;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 50px;
            text-align: center;
        }
        
        h1 {
            font-size: 3em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.3em;
            opacity: 0.95;
        }
        
        nav {
            background: #f8f9fa;
            padding: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .nav-links {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .nav-links a {
            padding: 10px 20px;
            background: white;
            color: #667eea;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .nav-links a:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
        }
        
        .content {
            padding: 50px;
        }
        
        .section {
            margin-bottom: 50px;
            padding: 40px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 6px solid #667eea;
        }
        
        h2 {
            color: #667eea;
            margin-bottom: 25px;
            font-size: 2.2em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }
        
        h3 {
            color: #764ba2;
            margin: 25px 0 15px 0;
            font-size: 1.6em;
        }
        
        h4 {
            color: #5a67d8;
            margin: 20px 0 10px 0;
            font-size: 1.3em;
        }
        
        .visual-graph {
            background: white;
            padding: 40px;
            border-radius: 15px;
            margin: 25px 0;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .graph-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
            position: relative;
            margin: 30px 0;
        }
        
        .graph-node {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 18px 28px;
            border-radius: 50%;
            font-weight: bold;
            font-size: 1.2em;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            min-width: 60px;
            position: absolute;
            transition: transform 0.3s ease;
        }
        
        .graph-node:hover {
            transform: scale(1.1);
            z-index: 10;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 25px;
            border-radius: 12px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.6;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            white-space: pre;
        }
        
        .code-block .comment {
            color: #95a5a6;
        }
        
        .code-block .keyword {
            color: #3498db;
        }
        
        .code-block .string {
            color: #e74c3c;
        }
        
        .code-block .function {
            color: #f39c12;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .card {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }
        
        .card h3 {
            margin-top: 0;
        }
        
        .highlight-box {
            background: #e3e8ff;
            border-left: 5px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .warning-box {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .info-box {
            background: #d1ecf1;
            border-left: 5px solid #17a2b8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        
        th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 15px;
            border-bottom: 1px solid #ecf0f1;
        }
        
        tr:hover {
            background: #f8f9fa;
        }
        
        code {
            background: #f4f4f4;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #e74c3c;
            font-size: 0.9em;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-top: 15px;
        }
        
        li {
            margin: 10px 0;
        }
        
        strong {
            color: #667eea;
        }
        
        .algorithm-box {
            background: white;
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
        }
        
        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }
            
            .section {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üï∏Ô∏è Graphs Data Structure</h1>
            <p class="subtitle">Complete Guide: From Basics to Advanced Algorithms</p>
        </header>
        
        <nav>
            <div class="nav-links">
                <a href="#basics">Basics</a>
                <a href="#terminology">Terminology</a>
                <a href="#types">Types</a>
                <a href="#representation">Representation</a>
                <a href="#traversal">Traversal</a>
                <a href="#shortest-path">Shortest Path</a>
                <a href="#mst">MST</a>
                <a href="#topological">Topological Sort</a>
                <a href="#advanced">Advanced</a>
                <a href="#complexity">Complexity</a>
            </div>
        </nav>
        
        <div class="content">
            <!-- BASICS -->
            <div class="section" id="basics">
                <h2>üéØ What is a Graph?</h2>
                <p>A <strong>Graph</strong> is a non-linear data structure consisting of <strong>vertices (nodes)</strong> connected by <strong>edges</strong>. Unlike trees, graphs can have cycles, multiple paths between nodes, and don't necessarily have a hierarchical structure.</p>
                
                <div class="highlight-box">
                    <h4>üîë Key Differences: Graph vs Tree</h4>
                    <table style="margin: 15px 0;">
                        <tr>
                            <th>Aspect</th>
                            <th>Tree</th>
                            <th>Graph</th>
                        </tr>
                        <tr>
                            <td><strong>Cycles</strong></td>
                            <td>No cycles allowed</td>
                            <td>Can have cycles</td>
                        </tr>
                        <tr>
                            <td><strong>Root</strong></td>
                            <td>Has one root node</td>
                            <td>No specific root</td>
                        </tr>
                        <tr>
                            <td><strong>Edges</strong></td>
                            <td>N-1 edges for N nodes</td>
                            <td>Any number of edges</td>
                        </tr>
                        <tr>
                            <td><strong>Hierarchy</strong></td>
                            <td>Hierarchical structure</td>
                            <td>Network structure</td>
                        </tr>
                        <tr>
                            <td><strong>Parent-Child</strong></td>
                            <td>Clear parent-child</td>
                            <td>No parent-child concept</td>
                        </tr>
                    </table>
                </div>
                
                <div class="visual-graph">
                    <h3>Basic Graph Structure</h3>
                    <svg width="400" height="300" style="border: 1px solid #e0e0e0; border-radius: 8px;">
                        <!-- Edges -->
                        <line x1="100" y1="80" x2="200" y2="80" stroke="#667eea" stroke-width="3"/>
                        <line x1="100" y1="80" x2="150" y2="180" stroke="#667eea" stroke-width="3"/>
                        <line x1="200" y1="80" x2="300" y2="80" stroke="#667eea" stroke-width="3"/>
                        <line x1="200" y1="80" x2="250" y2="180" stroke="#667eea" stroke-width="3"/>
                        <line x1="150" y1="180" x2="250" y2="180" stroke="#667eea" stroke-width="3"/>
                        
                        <!-- Nodes -->
                        <circle cx="100" cy="80" r="30" fill="#667eea"/>
                        <text x="100" y="90" text-anchor="middle" fill="white" font-size="20" font-weight="bold">A</text>
                        
                        <circle cx="200" cy="80" r="30" fill="#667eea"/>
                        <text x="200" y="90" text-anchor="middle" fill="white" font-size="20" font-weight="bold">B</text>
                        
                        <circle cx="300" cy="80" r="30" fill="#667eea"/>
                        <text x="300" y="90" text-anchor="middle" fill="white" font-size="20" font-weight="bold">C</text>
                        
                        <circle cx="150" cy="180" r="30" fill="#667eea"/>
                        <text x="150" y="190" text-anchor="middle" fill="white" font-size="20" font-weight="bold">D</text>
                        
                        <circle cx="250" cy="180" r="30" fill="#667eea"/>
                        <text x="250" y="190" text-anchor="middle" fill="white" font-size="20" font-weight="bold">E</text>
                    </svg>
                    <p><em>Undirected graph with 5 vertices and 5 edges</em></p>
                </div>
                
                <div class="info-box">
                    <h4>üìê Graph Notation: G = (V, E)</h4>
                    <ul>
                        <li><strong>V</strong> = Set of vertices/nodes: {A, B, C, D, E}</li>
                        <li><strong>E</strong> = Set of edges: {(A,B), (A,D), (B,C), (B,E), (D,E)}</li>
                        <li><strong>|V|</strong> = Number of vertices (5 in above example)</li>
                        <li><strong>|E|</strong> = Number of edges (5 in above example)</li>
                    </ul>
                </div>
            </div>
            
            <!-- TERMINOLOGY -->
            <div class="section" id="terminology">
                <h2>üìö Essential Terminology</h2>
                
                <div class="comparison-grid">
                    <div class="card">
                        <h3>Vertex/Node</h3>
                        <p>Fundamental unit representing an entity (person, city, web page)</p>
                    </div>
                    <div class="card">
                        <h3>Edge/Arc</h3>
                        <p>Connection between two vertices (friendship, road, link)</p>
                    </div>
                    <div class="card">
                        <h3>Adjacent Vertices</h3>
                        <p>Two vertices connected by an edge are neighbors/adjacent</p>
                    </div>
                    <div class="card">
                        <h3>Degree</h3>
                        <p>Number of edges connected to a vertex</p>
                    </div>
                    <div class="card">
                        <h3>In-Degree</h3>
                        <p>Number of incoming edges (in directed graphs)</p>
                    </div>
                    <div class="card">
                        <h3>Out-Degree</h3>
                        <p>Number of outgoing edges (in directed graphs)</p>
                    </div>
                    <div class="card">
                        <h3>Path</h3>
                        <p>Sequence of vertices where each adjacent pair is connected by an edge</p>
                    </div>
                    <div class="card">
                        <h3>Cycle</h3>
                        <p>Path that starts and ends at the same vertex</p>
                    </div>
                    <div class="card">
                        <h3>Connected Graph</h3>
                        <p>There exists a path between every pair of vertices</p>
                    </div>
                    <div class="card">
                        <h3>Disconnected Graph</h3>
                        <p>At least one vertex is unreachable from another</p>
                    </div>
                    <div class="card">
                        <h3>Weighted Graph</h3>
                        <p>Edges have associated weights/costs</p>
                    </div>
                    <div class="card">
                        <h3>Complete Graph</h3>
                        <p>Every vertex is connected to every other vertex</p>
                    </div>
                </div>
                
                <h3>More Advanced Terms</h3>
                <table>
                    <tr>
                        <th>Term</th>
                        <th>Definition</th>
                        <th>Example/Note</th>
                    </tr>
                    <tr>
                        <td><strong>Strongly Connected</strong></td>
                        <td>Every vertex is reachable from every other (directed)</td>
                        <td>Can go from any node to any node</td>
                    </tr>
                    <tr>
                        <td><strong>Weakly Connected</strong></td>
                        <td>Connected if we ignore edge directions</td>
                        <td>Underlying undirected graph is connected</td>
                    </tr>
                    <tr>
                        <td><strong>Acyclic Graph</strong></td>
                        <td>Graph with no cycles</td>
                        <td>DAG = Directed Acyclic Graph</td>
                    </tr>
                    <tr>
                        <td><strong>Spanning Tree</strong></td>
                        <td>Subgraph that includes all vertices with minimum edges</td>
                        <td>No cycles, |V|-1 edges</td>
                    </tr>
                    <tr>
                        <td><strong>Bridge</strong></td>
                        <td>Edge whose removal disconnects the graph</td>
                        <td>Critical connection</td>
                    </tr>
                    <tr>
                        <td><strong>Articulation Point</strong></td>
                        <td>Vertex whose removal disconnects the graph</td>
                        <td>Also called cut vertex</td>
                    </tr>
                </table>
            </div>
            
            <!-- TYPES OF GRAPHS -->
            <div class="section" id="types">
                <h2>üåê Types of Graphs</h2>
                
                <h3>1. Based on Edge Direction</h3>
                
                <div class="comparison-grid">
                    <div class="card">
                        <h3>Undirected Graph</h3>
                        <p>Edges have no direction (bidirectional)</p>
                        <p><strong>Example:</strong> Facebook friendship</p>
                        <svg width="200" height="150" style="margin: 10px 0;">
                            <line x1="50" y1="50" x2="150" y2="50" stroke="#667eea" stroke-width="3"/>
                            <circle cx="50" cy="50" r="20" fill="#667eea"/>
                            <text x="50" y="58" text-anchor="middle" fill="white" font-weight="bold">A</text>
                            <circle cx="150" cy="50" r="20" fill="#667eea"/>
                            <text x="150" y="58" text-anchor="middle" fill="white" font-weight="bold">B</text>
                        </svg>
                        <p><em>Edge (A,B) = Edge (B,A)</em></p>
                    </div>
                    <div class="card">
                        <h3>Directed Graph (Digraph)</h3>
                        <p>Edges have direction (arrows)</p>
                        <p><strong>Example:</strong> Twitter following</p>
                        <svg width="200" height="150" style="margin: 10px 0;">
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                    <polygon points="0 0, 10 3, 0 6" fill="#667eea" />
                                </marker>
                            </defs>
                            <line x1="70" y1="50" x2="130" y2="50" stroke="#667eea" stroke-width="3" marker-end="url(#arrowhead)"/>
                            <circle cx="50" cy="50" r="20" fill="#667eea"/>
                            <text x="50" y="58" text-anchor="middle" fill="white" font-weight="bold">A</text>
                            <circle cx="150" cy="50" r="20" fill="#667eea"/>
                            <text x="150" y="58" text-anchor="middle" fill="white" font-weight="bold">B</text>
                        </svg>
                        <p><em>Edge A‚ÜíB ‚â† Edge B‚ÜíA</em></p>
                    </div>
                </div>
                
                <h3>2. Based on Edge Weights</h3>
                
                <div class="comparison-grid">
                    <div class="card">
                        <h3>Unweighted Graph</h3>
                        <p>All edges are equal (no weights)</p>
                        <p><strong>Use Case:</strong> Social networks, web pages</p>
<div class="code-block">A --- B
|     |
C --- D

All edges have equal importance</div>
                    </div>
                    <div class="card">
                        <h3>Weighted Graph</h3>
                        <p>Edges have associated weights/costs</p>
                        <p><strong>Use Case:</strong> Road networks, flight routes</p>
<div class="code-block">A --5-- B
|       |
3       2
|       |
C --4-- D

Numbers represent distances/costs</div>
                    </div>
                </div>
                
                <h3>3. Special Graph Types</h3>
                
                <table>
                    <tr>
                        <th>Type</th>
                        <th>Description</th>
                        <th>Properties</th>
                        <th>Use Case</th>
                    </tr>
                    <tr>
                        <td><strong>Complete Graph</strong></td>
                        <td>Every vertex connected to every other vertex</td>
                        <td>|E| = n(n-1)/2</td>
                        <td>Traveling salesman problem</td>
                    </tr>
                    <tr>
                        <td><strong>Cyclic Graph</strong></td>
                        <td>Contains at least one cycle</td>
                        <td>Path starts and ends at same vertex</td>
                        <td>Detecting deadlocks</td>
                    </tr>
                    <tr>
                        <td><strong>Acyclic Graph</strong></td>
                        <td>No cycles present</td>
                        <td>Tree is acyclic connected graph</td>
                        <td>Task scheduling</td>
                    </tr>
                    <tr>
                        <td><strong>DAG</strong></td>
                        <td>Directed Acyclic Graph</td>
                        <td>No directed cycles</td>
                        <td>Build systems, prerequisites</td>
                    </tr>
                    <tr>
                        <td><strong>Bipartite Graph</strong></td>
                        <td>Vertices in 2 sets, edges only between sets</td>
                        <td>No odd-length cycles</td>
                        <td>Matching problems, 2-coloring</td>
                    </tr>
                    <tr>
                        <td><strong>Multigraph</strong></td>
                        <td>Multiple edges between same vertices</td>
                        <td>Can have parallel edges</td>
                        <td>Transportation networks</td>
                    </tr>
                    <tr>
                        <td><strong>Connected Graph</strong></td>
                        <td>Path exists between all vertex pairs</td>
                        <td>Single component</td>
                        <td>Network connectivity</td>
                    </tr>
                    <tr>
                        <td><strong>Disconnected Graph</strong></td>
                        <td>Multiple separate components</td>
                        <td>No path between some vertices</td>
                        <td>Social network clusters</td>
                    </tr>
                </table>
            </div>
            
            <!-- GRAPH REPRESENTATION -->
            <div class="section" id="representation">
                <h2>üíæ Graph Representation</h2>
                <p>Three main ways to represent graphs in code. Choice depends on graph density and operations needed.</p>
                
                <h3>1. Adjacency Matrix</h3>
                <p>2D array where matrix[i][j] = 1 if edge exists between vertex i and j</p>
                
                <div class="visual-graph">
                    <h4>Example Graph:</h4>
                    <svg width="300" height="200">
                        <line x1="80" y1="60" x2="150" y2="60" stroke="#667eea" stroke-width="2"/>
                        <line x1="80" y1="60" x2="80" y2="130" stroke="#667eea" stroke-width="2"/>
                        <line x1="150" y1="60" x2="220" y2="60" stroke="#667eea" stroke-width="2"/>
                        <line x1="150" y1="60" x2="150" y2="130" stroke="#667eea" stroke-width="2"/>
                        
                        <circle cx="80" cy="60" r="25" fill="#667eea"/>
                        <text x="80" y="70" text-anchor="middle" fill="white" font-weight="bold">0</text>
                        
                        <circle cx="150" cy="60" r="25" fill="#667eea"/>
                        <text x="150" y="70" text-anchor="middle" fill="white" font-weight="bold">1</text>
                        
                        <circle cx="220" cy="60" r="25" fill="#667eea"/>
                        <text x="220" y="70" text-anchor="middle" fill="white" font-weight="bold">2</text>
                        
                        <circle cx="80" cy="130" r="25" fill="#667eea"/>
                        <text x="80" y="140" text-anchor="middle" fill="white" font-weight="bold">3</text>
                        
                        <circle cx="150" cy="130" r="25" fill="#667eea"/>
                        <text x="150" y="140" text-anchor="middle" fill="white" font-weight="bold">4</text>
                    </svg>
                    
                    <h4 style="margin-top: 20px;">Adjacency Matrix:</h4>
                    <table style="width: auto; margin: 20px auto;">
                        <tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr>
                        <tr><th>0</th><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
                        <tr><th>1</th><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
                        <tr><th>2</th><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
                        <tr><th>3</th><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                        <tr><th>4</th><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
                    </table>
                </div>
                
<div class="code-block"><span class="keyword">class</span> <span class="function">GraphMatrix</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, vertices):
        self.V = vertices
        self.graph = [[0] * vertices <span class="keyword">for</span> _ <span class="keyword">in</span> range(vertices)]
    
    <span class="keyword">def</span> <span class="function">add_edge</span>(self, u, v):
        <span class="comment"># For undirected graph</span>
        self.graph[u][v] = 1
        self.graph[v][u] = 1
    
    <span class="keyword">def</span> <span class="function">add_edge_directed</span>(self, u, v):
        <span class="comment"># For directed graph</span>
        self.graph[u][v] = 1
    
    <span class="keyword">def</span> <span class="function">add_weighted_edge</span>(self, u, v, weight):
        <span class="comment"># For weighted graph</span>
        self.graph[u][v] = weight
        self.graph[v][u] = weight

<span class="comment"># Usage</span>
g = GraphMatrix(5)
g.add_edge(0, 1)
g.add_edge(0, 3)
g.add_edge(1, 2)
g.add_edge(1, 4)</div>

                <div class="highlight-box">
                    <h4>‚úÖ Pros:</h4>
                    <ul>
                        <li>Edge lookup: <strong>O(1)</strong> - just check matrix[i][j]</li>
                        <li>Simple to implement and understand</li>
                        <li>Good for dense graphs (many edges)</li>
                        <li>Easy to represent weighted graphs</li>
                    </ul>
                    <h4>‚ùå Cons:</h4>
                    <ul>
                        <li>Space: <strong>O(V¬≤)</strong> - wasteful for sparse graphs</li>
                        <li>Getting all neighbors: <strong>O(V)</strong> - must scan entire row</li>
                        <li>Not efficient for adding/removing vertices</li>
                    </ul>
                </div>
                
                <h3>2. Adjacency List</h3>
                <p>Array of lists where each index stores neighbors of that vertex</p>
                
                <div class="visual-graph">
                    <h4>Same Graph as Adjacency List:</h4>
                    <div class="code-block">0 ‚Üí [1, 3]
1 ‚Üí [0, 2, 4]
2 ‚Üí [1]
3 ‚Üí [0]
4 ‚Üí [1]</div>
                </div>
                
<div class="code-block"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict

<span class="keyword">class</span> <span class="function">GraphList</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.graph = defaultdict(list)
    
    <span class="keyword">def</span> <span class="function">add_edge</span>(self, u, v):
        <span class="comment"># For undirected graph</span>
        self.graph[u].append(v)
        self.graph[v].append(u)
    
    <span class="keyword">def</span> <span class="function">add_edge_directed</span>(self, u, v):
        <span class="comment"># For directed graph</span>
        self.graph[u].append(v)
    
    <span class="keyword">def</span> <span class="function">add_weighted_edge</span>(self, u, v, weight):
        <span class="comment"># For weighted graph - store (neighbor, weight) tuples</span>
        self.graph[u].append((v, weight))
        self.graph[v].append((u, weight))

<span class="comment"># Usage</span>
g = GraphList()
g.add_edge(0, 1)
g.add_edge(0, 3)
g.add_edge(1, 2)
g.add_edge(1, 4)</div>

                <div class="highlight-box">
                    <h4>‚úÖ Pros:</h4>
                    <ul>
                        <li>Space: <strong>O(V + E)</strong> - efficient for sparse graphs</li>
                        <li>Get all neighbors: <strong>O(degree)</strong> - only actual neighbors</li>
                        <li>Easy to iterate over edges</li>
                        <li>Most common in real-world applications</li>
                    </ul>
                    <h4>‚ùå Cons:</h4>
                    <ul>
                        <li>Edge lookup: <strong>O(degree)</strong> - must search list</li>
                        <li>Slightly more complex to implement</li>
                    </ul>
                </div>
                
                <h3>3. Edge List</h3>
                <p>Simple list of all edges as pairs (or triples for weighted)</p>
                
<div class="code-block"><span class="keyword">class</span> <span class="function">GraphEdgeList</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.edges = []
        self.vertices = set()
    
    <span class="keyword">def</span> <span class="function">add_edge</span>(self, u, v, weight=1):
        self.edges.append((u, v, weight))
        self.vertices.add(u)
        self.vertices.add(v)

<span class="comment"># Usage</span>
g = GraphEdgeList()
g.add_edge(0, 1)
g.add_edge(0, 3)
g.add_edge(1, 2, 5)  <span class="comment"># weighted edge</span>

<span class="comment"># Edge list: [(0,1,1), (0,3,1), (1,2,5)]</span></div>

                <div class="info-box">
                    <h4>When to use Edge List?</h4>
                    <ul>
                        <li><strong>Kruskal's MST algorithm</strong> - needs sorted edges</li>
                        <li><strong>Union-Find operations</strong></li>
                        <li>When you primarily iterate over all edges</li>
                        <li>Simple storage and transmission</li>
                    </ul>
                </div>
                
                <h3>Representation Comparison</h3>
                <table>
                    <tr>
                        <th>Operation</th>
                        <th>Adjacency Matrix</th>
                        <th>Adjacency List</th>
                        <th>Edge List</th>
                    </tr>
                    <tr>
                        <td><strong>Space</strong></td>
                        <td>O(V¬≤)</td>
                        <td>O(V + E)</td>
                        <td>O(E)</td>
                    </tr>
                    <tr>
                        <td><strong>Check if edge exists</strong></td>
                        <td>O(1)</td>
                        <td>O(degree)</td>
                        <td>O(E)</td>
                    </tr>
                    <tr>
                        <td><strong>Get all neighbors</strong></td>
                        <td>O(V)</td>
                        <td>O(degree)</td>
                        <td>O(E)</td>
                    </tr>
                    <tr>
                        <td><strong>Add edge</strong></td>
                        <td>O(1)</td>
                        <td>O(1)</td>
                        <td>O(1)</td>
                    </tr>
                    <tr>
                        <td><strong>Best for</strong></td>
                        <td>Dense graphs</td>
                        <td>Sparse graphs</td>
                        <td>MST algorithms</td>
                    </tr>
                </table>
            </div>
            
            <!-- GRAPH TRAVERSAL -->
            <div class="section" id="traversal">
                <h2>üîÑ Graph Traversal Algorithms</h2>
                <p>Two fundamental ways to explore graphs: BFS (breadth-first) and DFS (depth-first)</p>
                
                <h3>1. Breadth-First Search (BFS)</h3>
                <p>Explores level by level, visiting all neighbors before going deeper. Uses a <strong>Queue</strong>.</p>
                
                <div class="algorithm-box">
                    <h4>üéØ BFS Algorithm:</h4>
                    <ol>
                        <li>Start from source vertex, mark it visited</li>
                        <li>Add source to queue</li>
                        <li>While queue is not empty:
                            <ul>
                                <li>Dequeue a vertex</li>
                                <li>Process/print it</li>
                                <li>Enqueue all unvisited neighbors and mark them visited</li>
                            </ul>
                        </li>
                    </ol>
                </div>
                
<div class="code-block"><span class="keyword">from</span> collections <span class="keyword">import</span> deque

<span class="keyword">def</span> <span class="function">bfs</span>(graph, start):
    <span class="comment">"""
    Breadth-First Search
    Time: O(V + E), Space: O(V)
    """</span>
    visited = set()
    queue = deque([start])
    visited.add(start)
    result = []
    
    <span class="keyword">while</span> queue:
        vertex = queue.popleft()
        result.append(vertex)
        
        <span class="comment"># Visit all neighbors</span>
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[vertex]:
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    <span class="keyword">return</span> result

<span class="comment"># Example usage</span>
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 4],
    3: [1],
    4: [1, 2]
}

print(bfs(graph, 0))  <span class="comment"># Output: [0, 1, 2, 3, 4]</span></div>

                <div class="highlight-box">
                    <h4>üéØ BFS Use Cases:</h4>
                    <ul>
                        <li><strong>Shortest path</strong> in unweighted graphs</li>
                        <li><strong>Level-order traversal</strong></li>
                        <li><strong>Check if graph is connected</strong></li>
                        <li><strong>Find all nodes within k distance</strong></li>
                        <li><strong>Web crawling</strong> - explore nearby links first</li>
                        <li><strong>Social networks</strong> - find friends within degrees of separation</li>
                    </ul>
                </div>
                
                <h3>2. Depth-First Search (DFS)</h3>
                <p>Explores as deep as possible before backtracking. Uses a <strong>Stack</strong> (or recursion).</p>
                
                <div class="algorithm-box">
                    <h4>üéØ DFS Algorithm:</h4>
                    <ol>
                        <li>Start from source vertex, mark it visited</li>
                        <li>Process/print current vertex</li>
                        <li>For each unvisited neighbor:
                            <ul>
                                <li>Recursively call DFS on that neighbor</li>
                            </ul>
                        </li>
                    </ol>
                </div>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">dfs_recursive</span>(graph, vertex, visited=None):
    <span class="comment">"""
    Depth-First Search (Recursive)
    Time: O(V + E), Space: O(V) for recursion stack
    """</span>
    <span class="keyword">if</span> visited <span class="keyword">is None</span>:
        visited = set()
    
    visited.add(vertex)
    result = [vertex]
    
    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[vertex]:
        <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
            result.extend(dfs_recursive(graph, neighbor, visited))
    
    <span class="keyword">return</span> result

<span class="keyword">def</span> <span class="function">dfs_iterative</span>(graph, start):
    <span class="comment">"""
    Depth-First Search (Iterative with Stack)
    Time: O(V + E), Space: O(V)
    """</span>
    visited = set()
    stack = [start]
    result = []
    
    <span class="keyword">while</span> stack:
        vertex = stack.pop()
        
        <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
            visited.add(vertex)
            result.append(vertex)
            
            <span class="comment"># Add neighbors to stack (reverse order for same order as recursive)</span>
            <span class="keyword">for</span> neighbor <span class="keyword">in</span> reversed(graph[vertex]):
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                    stack.append(neighbor)
    
    <span class="keyword">return</span> result

<span class="comment"># Example usage</span>
print(dfs_recursive(graph, 0))  <span class="comment"># Output: [0, 1, 3, 4, 2]</span>
print(dfs_iterative(graph, 0))  <span class="comment"># Output: [0, 1, 3, 4, 2]</span></div>

                <div class="highlight-box">
                    <h4>üéØ DFS Use Cases:</h4>
                    <ul>
                        <li><strong>Cycle detection</strong> in graphs</li>
                        <li><strong>Topological sorting</strong> (DAG)</li>
                        <li><strong>Find connected components</strong></li>
                        <li><strong>Maze solving</strong> - explore one path fully</li>
                        <li><strong>Backtracking problems</strong> (Sudoku, N-Queens)</li>
                        <li><strong>Finding strongly connected components</strong> (Tarjan's, Kosaraju's)</li>
                    </ul>
                </div>
                
                <h3>BFS vs DFS Comparison</h3>
                <table>
                    <tr>
                        <th>Aspect</th>
                        <th>BFS</th>
                        <th>DFS</th>
                    </tr>
                    <tr>
                        <td><strong>Data Structure</strong></td>
                        <td>Queue (FIFO)</td>
                        <td>Stack (LIFO) or Recursion</td>
                    </tr>
                    <tr>
                        <td><strong>Exploration</strong></td>
                        <td>Level by level</td>
                        <td>Deep first, then backtrack</td>
                    </tr>
                    <tr>
                        <td><strong>Shortest Path</strong></td>
                        <td>‚úÖ Yes (unweighted)</td>
                        <td>‚ùå No</td>
                    </tr>
                    <tr>
                        <td><strong>Memory</strong></td>
                        <td>More memory (stores level)</td>
                        <td>Less memory (stack depth)</td>
                    </tr>
                    <tr>
                        <td><strong>Complete</strong></td>
                        <td>‚úÖ Yes</td>
                        <td>‚ùå Can get stuck in infinite path</td>
                    </tr>
                    <tr>
                        <td><strong>Optimal</strong></td>
                        <td>‚úÖ Yes (unweighted)</td>
                        <td>‚ùå No</td>
                    </tr>
                    <tr>
                        <td><strong>Time Complexity</strong></td>
                        <td>O(V + E)</td>
                        <td>O(V + E)</td>
                    </tr>
                </table>
            </div>
            
            <!-- SHORTEST PATH ALGORITHMS -->
            <div class="section" id="shortest-path">
                <h2>üõ£Ô∏è Shortest Path Algorithms</h2>
                
                <h3>1. Dijkstra's Algorithm</h3>
                <p>Finds shortest path from source to all vertices in <strong>weighted graph with non-negative weights</strong>.</p>
                
                <div class="algorithm-box">
                    <h4>üéØ Dijkstra's Algorithm Steps:</h4>
                    <ol>
                        <li>Initialize distances: source = 0, all others = ‚àû</li>
                        <li>Use min-heap/priority queue with (distance, vertex)</li>
                        <li>While heap is not empty:
                            <ul>
                                <li>Extract vertex with minimum distance</li>
                                <li>For each neighbor, if new path is shorter, update distance</li>
                                <li>Add updated neighbor to heap</li>
                            </ul>
                        </li>
                    </ol>
                </div>
                
<div class="code-block"><span class="keyword">import</span> heapq

<span class="keyword">def</span> <span class="function">dijkstra</span>(graph, start):
    <span class="comment">"""
    Dijkstra's Shortest Path Algorithm
    Time: O((V + E) log V) with min-heap
    Space: O(V)
    Works only with NON-NEGATIVE weights
    """</span>
    distances = {vertex: float(<span class="string">'infinity'</span>) <span class="keyword">for</span> vertex <span class="keyword">in</span> graph}
    distances[start] = 0
    
    <span class="comment"># Min-heap: (distance, vertex)</span>
    pq = [(0, start)]
    visited = set()
    
    <span class="keyword">while</span> pq:
        current_dist, current = heapq.heappop(pq)
        
        <span class="keyword">if</span> current <span class="keyword">in</span> visited:
            <span class="keyword">continue</span>
        visited.add(current)
        
        <span class="comment"># Check all neighbors</span>
        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph[current]:
            distance = current_dist + weight
            
            <span class="comment"># Relaxation: found shorter path</span>
            <span class="keyword">if</span> distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))
    
    <span class="keyword">return</span> distances

<span class="comment"># Example: Weighted graph as adjacency list</span>
weighted_graph = {
    <span class="string">'A'</span>: [(<span class="string">'B'</span>, 4), (<span class="string">'C'</span>, 2)],
    <span class="string">'B'</span>: [(<span class="string">'A'</span>, 4), (<span class="string">'C'</span>, 1), (<span class="string">'D'</span>, 5)],
    <span class="string">'C'</span>: [(<span class="string">'A'</span>, 2), (<span class="string">'B'</span>, 1), (<span class="string">'D'</span>, 8)],
    <span class="string">'D'</span>: [(<span class="string">'B'</span>, 5), (<span class="string">'C'</span>, 8)]
}

print(dijkstra(weighted_graph, <span class="string">'A'</span>))
<span class="comment"># Output: {'A': 0, 'B': 3, 'C': 2, 'D': 8}</span></div>

                <div class="warning-box">
                    <strong>‚ö†Ô∏è Important:</strong> Dijkstra's algorithm does NOT work with negative weights! Use Bellman-Ford for negative weights.
                </div>
                
                <h3>2. Bellman-Ford Algorithm</h3>
                <p>Finds shortest path even with <strong>negative weights</strong>. Can detect <strong>negative cycles</strong>.</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">bellman_ford</span>(vertices, edges, start):
    <span class="comment">"""
    Bellman-Ford Algorithm
    Time: O(V * E) - slower than Dijkstra
    Space: O(V)
    Works with NEGATIVE weights, detects negative cycles
    """</span>
    <span class="comment"># Initialize distances</span>
    distances = {v: float(<span class="string">'infinity'</span>) <span class="keyword">for</span> v <span class="keyword">in</span> vertices}
    distances[start] = 0
    
    <span class="comment"># Relax edges V-1 times</span>
    <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(vertices) - 1):
        <span class="keyword">for</span> u, v, weight <span class="keyword">in</span> edges:
            <span class="keyword">if</span> distances[u] != float(<span class="string">'infinity'</span>) <span class="keyword">and</span> distances[u] + weight < distances[v]:
                distances[v] = distances[u] + weight
    
    <span class="comment"># Check for negative cycles</span>
    <span class="keyword">for</span> u, v, weight <span class="keyword">in</span> edges:
        <span class="keyword">if</span> distances[u] != float(<span class="string">'infinity'</span>) <span class="keyword">and</span> distances[u] + weight < distances[v]:
            print(<span class="string">"Negative cycle detected!"</span>)
            <span class="keyword">return None</span>
    
    <span class="keyword">return</span> distances

<span class="comment"># Example: Edge list representation</span>
vertices = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>]
edges = [
    (<span class="string">'A'</span>, <span class="string">'B'</span>, 4),
    (<span class="string">'A'</span>, <span class="string">'C'</span>, 2),
    (<span class="string">'B'</span>, <span class="string">'C'</span>, -3),  <span class="comment"># Negative weight</span>
    (<span class="string">'B'</span>, <span class="string">'D'</span>, 2),
    (<span class="string">'C'</span>, <span class="string">'D'</span>, 3)
]

print(bellman_ford(vertices, edges, <span class="string">'A'</span>))
<span class="comment"># Output: {'A': 0, 'B': 4, 'C': 1, 'D': 4}</span></div>

                <h3>3. Floyd-Warshall Algorithm</h3>
                <p>Finds shortest paths between <strong>all pairs of vertices</strong>. Uses dynamic programming.</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">floyd_warshall</span>(graph):
    <span class="comment">"""
    Floyd-Warshall All-Pairs Shortest Path
    Time: O(V¬≥) - use when you need all pairs
    Space: O(V¬≤)
    """</span>
    V = len(graph)
    dist = [[float(<span class="string">'inf'</span>)] * V <span class="keyword">for</span> _ <span class="keyword">in</span> range(V)]
    
    <span class="comment"># Initialize distances</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(V):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(V):
            <span class="keyword">if</span> i == j:
                dist[i][j] = 0
            <span class="keyword">elif</span> graph[i][j] != 0:
                dist[i][j] = graph[i][j]
    
    <span class="comment"># Try all intermediate vertices</span>
    <span class="keyword">for</span> k <span class="keyword">in</span> range(V):
        <span class="keyword">for</span> i <span class="keyword">in</span> range(V):
            <span class="keyword">for</span> j <span class="keyword">in</span> range(V):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    <span class="keyword">return</span> dist

<span class="comment"># Example: Adjacency matrix</span>
INF = float(<span class="string">'inf'</span>)
graph_matrix = [
    [0, 3, INF, 7],
    [8, 0, 2, INF],
    [5, INF, 0, 1],
    [2, INF, INF, 0]
]

result = floyd_warshall(graph_matrix)
<span class="keyword">for</span> row <span class="keyword">in</span> result:
    print(row)</div>

                <h3>Shortest Path Algorithm Comparison</h3>
                <table>
                    <tr>
                        <th>Algorithm</th>
                        <th>Time Complexity</th>
                        <th>Negative Weights?</th>
                        <th>Use Case</th>
                    </tr>
                    <tr>
                        <td><strong>BFS</strong></td>
                        <td>O(V + E)</td>
                        <td>N/A (unweighted)</td>
                        <td>Unweighted graphs</td>
                    </tr>
                    <tr>
                        <td><strong>Dijkstra</strong></td>
                        <td>O((V+E) log V)</td>
                        <td>‚ùå No</td>
                        <td>Single source, non-negative weights</td>
                    </tr>
                    <tr>
                        <td><strong>Bellman-Ford</strong></td>
                        <td>O(V * E)</td>
                        <td>‚úÖ Yes</td>
                        <td>Single source, negative weights, detect cycles</td>
                    </tr>
                    <tr>
                        <td><strong>Floyd-Warshall</strong></td>
                        <td>O(V¬≥)</td>
                        <td>‚úÖ Yes</td>
                        <td>All pairs shortest paths</td>
                    </tr>
                </table>
            </div>
            
            <!-- MINIMUM SPANNING TREE -->
            <div class="section" id="mst">
                <h2>üå≥ Minimum Spanning Tree (MST)</h2>
                <p>A <strong>spanning tree</strong> is a subset of edges that connects all vertices with no cycles. <strong>MST</strong> is the spanning tree with minimum total edge weight.</p>
                
                <div class="info-box">
                    <h4>MST Properties:</h4>
                    <ul>
                        <li>Connects all V vertices</li>
                        <li>Has exactly V-1 edges</li>
                        <li>No cycles (it's a tree!)</li>
                        <li>Minimum total weight among all spanning trees</li>
                    </ul>
                </div>
                
                <h3>1. Kruskal's Algorithm</h3>
                <p>Greedy algorithm that builds MST by adding edges in <strong>increasing weight order</strong>, avoiding cycles.</p>
                
                <div class="algorithm-box">
                    <h4>üéØ Kruskal's Steps:</h4>
                    <ol>
                        <li>Sort all edges by weight (ascending)</li>
                        <li>Initialize Union-Find data structure</li>
                        <li>For each edge (u, v):
                            <ul>
                                <li>If u and v are in different components, add edge to MST</li>
                                <li>Union the two components</li>
                            </ul>
                        </li>
                        <li>Stop when MST has V-1 edges</li>
                    </ol>
                </div>
                
<div class="code-block"><span class="keyword">class</span> <span class="function">UnionFind</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    <span class="keyword">def</span> <span class="function">find</span>(self, x):
        <span class="comment"># Path compression</span>
        <span class="keyword">if</span> self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        <span class="keyword">return</span> self.parent[x]
    
    <span class="keyword">def</span> <span class="function">union</span>(self, x, y):
        <span class="comment"># Union by rank</span>
        px, py = self.find(x), self.find(y)
        <span class="keyword">if</span> px == py:
            <span class="keyword">return False</span>
        
        <span class="keyword">if</span> self.rank[px] < self.rank[py]:
            self.parent[px] = py
        <span class="keyword">elif</span> self.rank[px] > self.rank[py]:
            self.parent[py] = px
        <span class="keyword">else</span>:
            self.parent[py] = px
            self.rank[px] += 1
        <span class="keyword">return True</span>

<span class="keyword">def</span> <span class="function">kruskal</span>(vertices, edges):
    <span class="comment">"""
    Kruskal's MST Algorithm
    Time: O(E log E) - dominated by sorting
    Space: O(V)
    """</span>
    <span class="comment"># Sort edges by weight</span>
    edges.sort(key=<span class="keyword">lambda</span> x: x[2])
    
    uf = UnionFind(vertices)
    mst = []
    total_weight = 0
    
    <span class="keyword">for</span> u, v, weight <span class="keyword">in</span> edges:
        <span class="comment"># If adding edge doesn't create cycle</span>
        <span class="keyword">if</span> uf.union(u, v):
            mst.append((u, v, weight))
            total_weight += weight
            
            <span class="comment"># MST complete when we have V-1 edges</span>
            <span class="keyword">if</span> len(mst) == vertices - 1:
                <span class="keyword">break</span>
    
    <span class="keyword">return</span> mst, total_weight

<span class="comment"># Example</span>
edges = [
    (0, 1, 4),
    (0, 2, 3),
    (1, 2, 1),
    (1, 3, 2),
    (2, 3, 4)
]

mst, weight = kruskal(4, edges)
print(<span class="string">f"MST: {mst}, Total Weight: {weight}"</span>)
<span class="comment"># Output: MST: [(1, 2, 1), (1, 3, 2), (0, 2, 3)], Total Weight: 6</span></div>

                <h3>2. Prim's Algorithm</h3>
                <p>Greedy algorithm that grows MST by adding <strong>minimum weight edge</strong> from tree to non-tree vertices.</p>
                
<div class="code-block"><span class="keyword">import</span> heapq

<span class="keyword">def</span> <span class="function">prim</span>(graph, start=0):
    <span class="comment">"""
    Prim's MST Algorithm
    Time: O((V + E) log V) with min-heap
    Space: O(V)
    """</span>
    mst = []
    visited = set([start])
    edges = [(weight, start, to) <span class="keyword">for</span> to, weight <span class="keyword">in</span> graph[start]]
    heapq.heapify(edges)
    total_weight = 0
    
    <span class="keyword">while</span> edges:
        weight, frm, to = heapq.heappop(edges)
        
        <span class="keyword">if</span> to <span class="keyword">not in</span> visited:
            visited.add(to)
            mst.append((frm, to, weight))
            total_weight += weight
            
            <span class="comment"># Add all edges from newly added vertex</span>
            <span class="keyword">for</span> next_to, next_weight <span class="keyword">in</span> graph[to]:
                <span class="keyword">if</span> next_to <span class="keyword">not in</span> visited:
                    heapq.heappush(edges, (next_weight, to, next_to))
    
    <span class="keyword">return</span> mst, total_weight

<span class="comment"># Example: Adjacency list with weights</span>
graph_weighted = {
    0: [(1, 4), (2, 3)],
    1: [(0, 4), (2, 1), (3, 2)],
    2: [(0, 3), (1, 1), (3, 4)],
    3: [(1, 2), (2, 4)]
}

mst, weight = prim(graph_weighted)
print(<span class="string">f"MST: {mst}, Total Weight: {weight}"</span>)
<span class="comment"># Output: MST: [(0, 2, 3), (2, 1, 1), (1, 3, 2)], Total Weight: 6</span></div>

                <h3>Kruskal vs Prim Comparison</h3>
                <table>
                    <tr>
                        <th>Aspect</th>
                        <th>Kruskal's</th>
                        <th>Prim's</th>
                    </tr>
                    <tr>
                        <td><strong>Approach</strong></td>
                        <td>Edge-based (add minimum edges)</td>
                        <td>Vertex-based (grow from one vertex)</td>
                    </tr>
                    <tr>
                        <td><strong>Data Structure</strong></td>
                        <td>Union-Find</td>
                        <td>Min-Heap/Priority Queue</td>
                    </tr>
                    <tr>
                        <td><strong>Time Complexity</strong></td>
                        <td>O(E log E)</td>
                        <td>O((V+E) log V)</td>
                    </tr>
                    <tr>
                        <td><strong>Best For</strong></td>
                        <td>Sparse graphs (few edges)</td>
                        <td>Dense graphs (many edges)</td>
                    </tr>
                    <tr>
                        <td><strong>Representation</strong></td>
                        <td>Works well with edge list</td>
                        <td>Works well with adjacency list</td>
                    </tr>
                </table>
            </div>
            
            <!-- TOPOLOGICAL SORT -->
            <div class="section" id="topological">
                <h2>üìä Topological Sort</h2>
                <p>Linear ordering of vertices in a <strong>Directed Acyclic Graph (DAG)</strong> such that for every edge u‚Üív, u comes before v.</p>
                
                <div class="info-box">
                    <h4>üéØ Key Points:</h4>
                    <ul>
                        <li>Only works on <strong>DAG</strong> (no cycles!)</li>
                        <li>If graph has cycle, topological sort is impossible</li>
                        <li>Used for task scheduling, build systems, course prerequisites</li>
                        <li>A DAG can have multiple valid topological orderings</li>
                    </ul>
                </div>
                
                <div class="visual-graph">
                    <h4>Example: Course Prerequisites</h4>
                    <svg width="500" height="250">
                        <defs>
                            <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                <polygon points="0 0, 10 3, 0 6" fill="#667eea" />
                            </marker>
                        </defs>
                        
                        <!-- Edges -->
                        <line x1="100" y1="60" x2="180" y2="60" stroke="#667eea" stroke-width="2" marker-end="url(#arrow)"/>
                        <line x1="100" y1="60" x2="180" y2="130" stroke="#667eea" stroke-width="2" marker-end="url(#arrow)"/>
                        <line x1="220" y1="60" x2="300" y2="60" stroke="#667eea" stroke-width="2" marker-end="url(#arrow)"/>
                        <line x1="220" y1="130" x2="300" y2="130" stroke="#667eea" stroke-width="2" marker-end="url(#arrow)"/>
                        <line x1="340" y1="60" x2="400" y2="95" stroke="#667eea" stroke-width="2" marker-end="url(#arrow)"/>
                        <line x1="340" y1="130" x2="400" y2="95" stroke="#667eea" stroke-width="2" marker-end="url(#arrow)"/>
                        
                        <!-- Nodes -->
                        <circle cx="60" cy="60" r="30" fill="#667eea"/>
                        <text x="60" y="68" text-anchor="middle" fill="white" font-weight="bold">A</text>
                        
                        <circle cx="200" cy="60" r="30" fill="#667eea"/>
                        <text x="200" y="68" text-anchor="middle" fill="white" font-weight="bold">B</text>
                        
                        <circle cx="320" cy="60" r="30" fill="#667eea"/>
                        <text x="320" y="68" text-anchor="middle" fill="white" font-weight="bold">D</text>
                        
                        <circle cx="200" cy="130" r="30" fill="#667eea"/>
                        <text x="200" y="138" text-anchor="middle" fill="white" font-weight="bold">C</text>
                        
                        <circle cx="320" cy="130" r="30" fill="#667eea"/>
                        <text x="320" y="138" text-anchor="middle" fill="white" font-weight="bold">E</text>
                        
                        <circle cx="420" cy="95" r="30" fill="#667eea"/>
                        <text x="420" y="103" text-anchor="middle" fill="white" font-weight="bold">F</text>
                    </svg>
                    <p><em>Valid topological order: A ‚Üí B ‚Üí C ‚Üí D ‚Üí E ‚Üí F (or A ‚Üí B ‚Üí D ‚Üí C ‚Üí E ‚Üí F)</em></p>
                </div>
                
                <h3>1. DFS-Based Topological Sort</h3>
                <p>Most common approach - uses DFS and adds vertices to stack in post-order.</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">topological_sort_dfs</span>(graph):
    <span class="comment">"""
    Topological Sort using DFS
    Time: O(V + E)
    Space: O(V)
    """</span>
    visited = set()
    stack = []
    
    <span class="keyword">def</span> <span class="function">dfs</span>(vertex):
        visited.add(vertex)
        
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph.get(vertex, []):
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                dfs(neighbor)
        
        <span class="comment"># Add to stack after visiting all descendants</span>
        stack.append(vertex)
    
    <span class="comment"># Process all vertices</span>
    <span class="keyword">for</span> vertex <span class="keyword">in</span> graph:
        <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
            dfs(vertex)
    
    <span class="keyword">return</span> stack[::-1]  <span class="comment"># Reverse to get correct order</span>

<span class="comment"># Example: Course prerequisites (DAG)</span>
dag = {
    <span class="string">'A'</span>: [<span class="string">'B'</span>, <span class="string">'C'</span>],
    <span class="string">'B'</span>: [<span class="string">'D'</span>],
    <span class="string">'C'</span>: [<span class="string">'E'</span>],
    <span class="string">'D'</span>: [<span class="string">'F'</span>],
    <span class="string">'E'</span>: [<span class="string">'F'</span>],
    <span class="string">'F'</span>: []
}

print(topological_sort_dfs(dag))
<span class="comment"># Output: ['A', 'C', 'E', 'B', 'D', 'F'] (one valid ordering)</span></div>

                <h3>2. Kahn's Algorithm (BFS-Based)</h3>
                <p>Uses in-degree and BFS. Also detects cycles!</p>
                
<div class="code-block"><span class="keyword">from</span> collections <span class="keyword">import</span> deque, defaultdict

<span class="keyword">def</span> <span class="function">topological_sort_kahn</span>(vertices, edges):
    <span class="comment">"""
    Kahn's Algorithm (BFS-based Topological Sort)
    Time: O(V + E)
    Space: O(V)
    Can detect cycles - if output length < vertices, cycle exists
    """</span>
    <span class="comment"># Build graph and calculate in-degrees</span>
    graph = defaultdict(list)
    in_degree = {v: 0 <span class="keyword">for</span> v <span class="keyword">in</span> vertices}
    
    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:
        graph[u].append(v)
        in_degree[v] += 1
    
    <span class="comment"># Start with vertices that have no incoming edges</span>
    queue = deque([v <span class="keyword">for</span> v <span class="keyword">in</span> vertices <span class="keyword">if</span> in_degree[v] == 0])
    result = []
    
    <span class="keyword">while</span> queue:
        vertex = queue.popleft()
        result.append(vertex)
        
        <span class="comment"># Reduce in-degree for neighbors</span>
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[vertex]:
            in_degree[neighbor] -= 1
            <span class="keyword">if</span> in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    <span class="comment"># Check for cycle</span>
    <span class="keyword">if</span> len(result) != len(vertices):
        <span class="keyword">return None</span>  <span class="comment"># Cycle detected!</span>
    
    <span class="keyword">return</span> result

<span class="comment"># Example</span>
vertices = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>]
edges = [
    (<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>),
    (<span class="string">'B'</span>, <span class="string">'D'</span>), (<span class="string">'C'</span>, <span class="string">'E'</span>),
    (<span class="string">'D'</span>, <span class="string">'F'</span>), (<span class="string">'E'</span>, <span class="string">'F'</span>)
]

print(topological_sort_kahn(vertices, edges))
<span class="comment"># Output: ['A', 'B', 'C', 'D', 'E', 'F'] (one valid ordering)</span></div>

                <h3>Cycle Detection in Directed Graph</h3>
<div class="code-block"><span class="keyword">def</span> <span class="function">has_cycle_directed</span>(graph):
    <span class="comment">"""
    Detect cycle in directed graph using DFS with 3 colors
    White (0): Not visited
    Gray (1): Currently in DFS stack (being processed)
    Black (2): Completely processed
    """</span>
    color = {v: 0 <span class="keyword">for</span> v <span class="keyword">in</span> graph}
    
    <span class="keyword">def</span> <span class="function">dfs</span>(vertex):
        color[vertex] = 1  <span class="comment"># Mark as gray (in progress)</span>
        
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph.get(vertex, []):
            <span class="keyword">if</span> color[neighbor] == 1:  <span class="comment"># Back edge found - cycle!</span>
                <span class="keyword">return True</span>
            <span class="keyword">if</span> color[neighbor] == 0 <span class="keyword">and</span> dfs(neighbor):
                <span class="keyword">return True</span>
        
        color[vertex] = 2  <span class="comment"># Mark as black (done)</span>
        <span class="keyword">return False</span>
    
    <span class="keyword">for</span> vertex <span class="keyword">in</span> graph:
        <span class="keyword">if</span> color[vertex] == 0:
            <span class="keyword">if</span> dfs(vertex):
                <span class="keyword">return True</span>
    
    <span class="keyword">return False</span>

<span class="comment"># Test with cycle</span>
graph_with_cycle = {
    <span class="string">'A'</span>: [<span class="string">'B'</span>],
    <span class="string">'B'</span>: [<span class="string">'C'</span>],
    <span class="string">'C'</span>: [<span class="string">'A'</span>]  <span class="comment"># Creates cycle: A‚ÜíB‚ÜíC‚ÜíA</span>
}
print(has_cycle_directed(graph_with_cycle))  <span class="comment"># True</span></div>
            </div>
            
            <!-- ADVANCED ALGORITHMS -->
            <div class="section" id="advanced">
                <h2>üöÄ Advanced Graph Algorithms</h2>
                
                <h3>1. Cycle Detection in Undirected Graph</h3>
<div class="code-block"><span class="keyword">def</span> <span class="function">has_cycle_undirected_dfs</span>(graph):
    <span class="comment">"""
    Detect cycle in undirected graph using DFS
    Time: O(V + E)
    """</span>
    visited = set()
    
    <span class="keyword">def</span> <span class="function">dfs</span>(vertex, parent):
        visited.add(vertex)
        
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph.get(vertex, []):
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                <span class="keyword">if</span> dfs(neighbor, vertex):
                    <span class="keyword">return True</span>
            <span class="keyword">elif</span> neighbor != parent:  <span class="comment"># Found visited node that's not parent</span>
                <span class="keyword">return True</span>  <span class="comment"># Cycle detected!</span>
        
        <span class="keyword">return False</span>
    
    <span class="keyword">for</span> vertex <span class="keyword">in</span> graph:
        <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
            <span class="keyword">if</span> dfs(vertex, <span class="keyword">None</span>):
                <span class="keyword">return True</span>
    
    <span class="keyword">return False</span>

<span class="keyword">def</span> <span class="function">has_cycle_undirected_union_find</span>(vertices, edges):
    <span class="comment">"""
    Detect cycle using Union-Find
    Time: O(E Œ±(V)) - Œ± is inverse Ackermann (nearly constant)
    """</span>
    uf = UnionFind(vertices)
    
    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:
        <span class="comment"># If both vertices already in same set, adding edge creates cycle</span>
        <span class="keyword">if</span> uf.find(u) == uf.find(v):
            <span class="keyword">return True</span>
        uf.union(u, v)
    
    <span class="keyword">return False</span></div>

                <h3>2. Connected Components</h3>
<div class="code-block"><span class="keyword">def</span> <span class="function">count_connected_components</span>(graph):
    <span class="comment">"""
    Count number of connected components
    Time: O(V + E)
    """</span>
    visited = set()
    count = 0
    
    <span class="keyword">def</span> <span class="function">dfs</span>(vertex):
        visited.add(vertex)
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph.get(vertex, []):
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                dfs(neighbor)
    
    <span class="keyword">for</span> vertex <span class="keyword">in</span> graph:
        <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
            dfs(vertex)
            count += 1  <span class="comment"># Found new component</span>
    
    <span class="keyword">return</span> count

<span class="keyword">def</span> <span class="function">get_connected_components</span>(graph):
    <span class="comment">"""
    Get all connected components as separate lists
    """</span>
    visited = set()
    components = []
    
    <span class="keyword">def</span> <span class="function">dfs</span>(vertex, component):
        visited.add(vertex)
        component.append(vertex)
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph.get(vertex, []):
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                dfs(neighbor, component)
    
    <span class="keyword">for</span> vertex <span class="keyword">in</span> graph:
        <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
            component = []
            dfs(vertex, component)
            components.append(component)
    
    <span class="keyword">return</span> components

<span class="comment"># Example: Disconnected graph</span>
disconnected = {
    0: [1, 2],
    1: [0],
    2: [0],
    3: [4],
    4: [3],
    5: []
}
print(count_connected_components(disconnected))  <span class="comment"># 3</span>
print(get_connected_components(disconnected))    <span class="comment"># [[0,1,2], [3,4], [5]]</span></div>

                <h3>3. Bipartite Graph Check</h3>
                <p>Check if graph can be colored with 2 colors (no adjacent vertices have same color)</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">is_bipartite_bfs</span>(graph):
    <span class="comment">"""
    Check if graph is bipartite using BFS and 2-coloring
    Time: O(V + E)
    """</span>
    color = {}
    
    <span class="keyword">for</span> start <span class="keyword">in</span> graph:
        <span class="keyword">if</span> start <span class="keyword">in</span> color:
            <span class="keyword">continue</span>
        
        queue = deque([start])
        color[start] = 0
        
        <span class="keyword">while</span> queue:
            vertex = queue.popleft()
            
            <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph.get(vertex, []):
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> color:
                    <span class="comment"># Color with opposite color</span>
                    color[neighbor] = 1 - color[vertex]
                    queue.append(neighbor)
                <span class="keyword">elif</span> color[neighbor] == color[vertex]:
                    <span class="comment"># Same color as parent - not bipartite!</span>
                    <span class="keyword">return False</span>
    
    <span class="keyword">return True</span>

<span class="comment"># Example</span>
bipartite_graph = {
    0: [1, 3],
    1: [0, 2],
    2: [1, 3],
    3: [0, 2]
}
print(is_bipartite_bfs(bipartite_graph))  <span class="comment"># True</span>

non_bipartite = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1]  <span class="comment"># Triangle - odd cycle</span>
}
print(is_bipartite_bfs(non_bipartite))  <span class="comment"># False</span></div>

                <h3>4. Bridges and Articulation Points</h3>
                <p>Critical connections whose removal disconnects the graph</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">find_bridges</span>(graph, n):
    <span class="comment">"""
    Find all bridges (critical edges) using Tarjan's algorithm
    Time: O(V + E)
    """</span>
    visited = [<span class="keyword">False</span>] * n
    disc = [0] * n  <span class="comment"># Discovery time</span>
    low = [0] * n   <span class="comment"># Lowest reachable vertex</span>
    parent = [-1] * n
    bridges = []
    timer = [0]
    
    <span class="keyword">def</span> <span class="function">dfs</span>(u):
        visited[u] = <span class="keyword">True</span>
        disc[u] = low[u] = timer[0]
        timer[0] += 1
        
        <span class="keyword">for</span> v <span class="keyword">in</span> graph[u]:
            <span class="keyword">if not</span> visited[v]:
                parent[v] = u
                dfs(v)
                
                low[u] = min(low[u], low[v])
                
                <span class="comment"># Bridge condition: can't reach back to u or before</span>
                <span class="keyword">if</span> low[v] > disc[u]:
                    bridges.append((u, v))
            
            <span class="keyword">elif</span> v != parent[u]:
                low[u] = min(low[u], disc[v])
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
        <span class="keyword">if not</span> visited[i]:
            dfs(i)
    
    <span class="keyword">return</span> bridges

<span class="comment"># Example</span>
graph_with_bridge = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1, 3],
    3: [2]  <span class="comment"># Edge (2,3) is a bridge</span>
}
print(find_bridges(graph_with_bridge, 4))  <span class="comment"># [(2, 3)]</span></div>

                <h3>5. Strongly Connected Components (Kosaraju's Algorithm)</h3>
                <p>For directed graphs - find maximal strongly connected subgraphs</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">kosaraju_scc</span>(graph):
    <span class="comment">"""
    Find Strongly Connected Components using Kosaraju's algorithm
    Time: O(V + E)
    Steps:
    1. Do DFS, push vertices to stack in finish time order
    2. Reverse the graph
    3. Do DFS on reversed graph in stack order
    """</span>
    visited = set()
    stack = []
    
    <span class="comment"># Step 1: Fill stack with finish times</span>
    <span class="keyword">def</span> <span class="function">dfs1</span>(vertex):
        visited.add(vertex)
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph.get(vertex, []):
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                dfs1(neighbor)
        stack.append(vertex)
    
    <span class="keyword">for</span> vertex <span class="keyword">in</span> graph:
        <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
            dfs1(vertex)
    
    <span class="comment"># Step 2: Reverse graph</span>
    reversed_graph = defaultdict(list)
    <span class="keyword">for</span> u <span class="keyword">in</span> graph:
        <span class="keyword">for</span> v <span class="keyword">in</span> graph[u]:
            reversed_graph[v].append(u)
    
    <span class="comment"># Step 3: DFS on reversed graph</span>
    visited.clear()
    sccs = []
    
    <span class="keyword">def</span> <span class="function">dfs2</span>(vertex, scc):
        visited.add(vertex)
        scc.append(vertex)
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> reversed_graph.get(vertex, []):
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                dfs2(neighbor, scc)
    
    <span class="keyword">while</span> stack:
        vertex = stack.pop()
        <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
            scc = []
            dfs2(vertex, scc)
            sccs.append(scc)
    
    <span class="keyword">return</span> sccs

<span class="comment"># Example</span>
directed_graph = {
    0: [1],
    1: [2],
    2: [0, 3],
    3: [4],
    4: [5],
    5: [3]
}
print(kosaraju_scc(directed_graph))
<span class="comment"># Output: [[0, 2, 1], [3, 5, 4]] - two SCCs</span></div>
            </div>
            
            <!-- TIME COMPLEXITY -->
            <div class="section" id="complexity">
                <h2>‚è±Ô∏è Time & Space Complexity</h2>
                
                <h3>Graph Operations Complexity</h3>
                <table>
                    <tr>
                        <th>Operation</th>
                        <th>Adjacency Matrix</th>
                        <th>Adjacency List</th>
                        <th>Notes</th>
                    </tr>
                    <tr>
                        <td><strong>Add Vertex</strong></td>
                        <td>O(V¬≤)</td>
                        <td>O(1)</td>
                        <td>Matrix needs resizing</td>
                    </tr>
                    <tr>
                        <td><strong>Add Edge</strong></td>
                        <td>O(1)</td>
                        <td>O(1)</td>
                        <td>Direct access vs append</td>
                    </tr>
                    <tr>
                        <td><strong>Remove Edge</strong></td>
                        <td>O(1)</td>
                        <td>O(E)</td>
                        <td>Need to find edge in list</td>
                    </tr>
                    <tr>
                        <td><strong>Check if Edge</strong></td>
                        <td>O(1)</td>
                        <td>O(V)</td>
                        <td>Worst case: check all neighbors</td>
                    </tr>
                    <tr>
                        <td><strong>Get Neighbors</strong></td>
                        <td>O(V)</td>
                        <td>O(1)</td>
                        <td>Scan row vs direct access</td>
                    </tr>
                    <tr>
                        <td><strong>Space</strong></td>
                        <td>O(V¬≤)</td>
                        <td>O(V + E)</td>
                        <td>List better for sparse graphs</td>
                    </tr>
                </table>
                
                <h3>Algorithm Complexity Summary</h3>
                <table>
                    <tr>
                        <th>Algorithm</th>
                        <th>Time Complexity</th>
                        <th>Space Complexity</th>
                        <th>Use Case</th>
                    </tr>
                    <tr>
                        <td><strong>BFS</strong></td>
                        <td>O(V + E)</td>
                        <td>O(V)</td>
                        <td>Shortest path (unweighted)</td>
                    </tr>
                    <tr>
                        <td><strong>DFS</strong></td>
                        <td>O(V + E)</td>
                        <td>O(V)</td>
                        <td>Cycle detection, topological sort</td>
                    </tr>
                    <tr>
                        <td><strong>Dijkstra</strong></td>
                        <td>O((V+E) log V)</td>
                        <td>O(V)</td>
                        <td>Shortest path (non-negative weights)</td>
                    </tr>
                    <tr>
                        <td><strong>Bellman-Ford</strong></td>
                        <td>O(V √ó E)</td>
                        <td>O(V)</td>
                        <td>Shortest path (negative weights)</td>
                    </tr>
                    <tr>
                        <td><strong>Floyd-Warshall</strong></td>
                        <td>O(V¬≥)</td>
                        <td>O(V¬≤)</td>
                        <td>All pairs shortest path</td>
                    </tr>
                    <tr>
                        <td><strong>Prim's MST</strong></td>
                        <td>O((V+E) log V)</td>
                        <td>O(V)</td>
                        <td>MST for dense graphs</td>
                    </tr>
                    <tr>
                        <td><strong>Kruskal's MST</strong></td>
                        <td>O(E log E)</td>
                        <td>O(V)</td>
                        <td>MST for sparse graphs</td>
                    </tr>
                    <tr>
                        <td><strong>Topological Sort</strong></td>
                        <td>O(V + E)</td>
                        <td>O(V)</td>
                        <td>Task scheduling (DAG only)</td>
                    </tr>
                    <tr>
                        <td><strong>Tarjan's SCC</strong></td>
                        <td>O(V + E)</td>
                        <td>O(V)</td>
                        <td>Find strongly connected components</td>
                    </tr>
                    <tr>
                        <td><strong>Union-Find</strong></td>
                        <td>O(Œ±(V)) per op</td>
                        <td>O(V)</td>
                        <td>Cycle detection, Kruskal's</td>
                    </tr>
                </table>
                
                <div class="info-box">
                    <h4>üìä Notation Guide:</h4>
                    <ul>
                        <li><strong>V</strong> = Number of vertices</li>
                        <li><strong>E</strong> = Number of edges</li>
                        <li><strong>Œ±(V)</strong> = Inverse Ackermann function (practically constant, ‚âà 4)</li>
                        <li><strong>Dense graph:</strong> E ‚âà V¬≤ (many edges)</li>
                        <li><strong>Sparse graph:</strong> E ‚âà V (few edges)</li>
                    </ul>
                </div>
            </div>
            
            <!-- REAL-WORLD APPLICATIONS -->
            <div class="section">
                <h2>üåç Real-World Applications</h2>
                
                <div class="comparison-grid">
                    <div class="card">
                        <h3>üó∫Ô∏è Google Maps</h3>
                        <p><strong>Algorithm:</strong> Dijkstra's, A*</p>
                        <p>Cities = vertices, roads = weighted edges</p>
                        <p>Find shortest/fastest route</p>
                    </div>
                    <div class="card">
                        <h3>üë• Social Networks</h3>
                        <p><strong>Algorithm:</strong> BFS, Connected Components</p>
                        <p>People = vertices, friendships = edges</p>
                        <p>Friend suggestions, degrees of separation</p>
                    </div>
                    <div class="card">
                        <h3>üåê Web Crawling</h3>
                        <p><strong>Algorithm:</strong> BFS, DFS</p>
                        <p>Pages = vertices, links = directed edges</p>
                        <p>PageRank, indexing</p>
                    </div>
                    <div class="card">
                        <h3>üì¶ Package Dependencies</h3>
                        <p><strong>Algorithm:</strong> Topological Sort</p>
                        <p>Packages = vertices, dependencies = edges</p>
                        <p>npm, pip, build order</p>
                    </div>
                    <div class="card">
                        <h3>üîå Network Routing</h3>
                        <p><strong>Algorithm:</strong> Dijkstra's, Bellman-Ford</p>
                        <p>Routers = vertices, connections = edges</p>
                        <p>Find optimal packet routes</p>
                    </div>
                    <div class="card">
                        <h3>‚úàÔ∏è Flight Routes</h3>
                        <p><strong>Algorithm:</strong> Shortest Path, MST</p>
                        <p>Cities = vertices, flights = weighted edges</p>
                        <p>Cheapest/fastest connections</p>
                    </div>
                    <div class="card">
                        <h3>üéì Course Prerequisites</h3>
                        <p><strong>Algorithm:</strong> Topological Sort, Cycle Detection</p>
                        <p>Courses = vertices, prerequisites = edges</p>
                        <p>Valid course order</p>
                    </div>
                    <div class="card">
                        <h3>üîê Deadlock Detection</h3>
                        <p><strong>Algorithm:</strong> Cycle Detection</p>
                        <p>Processes = vertices, waiting = edges</p>
                        <p>Find circular wait conditions</p>
                    </div>
                    <div class="card">
                        <h3>üè≠ Supply Chain</h3>
                        <p><strong>Algorithm:</strong> MST, Network Flow</p>
                        <p>Warehouses = vertices, routes = edges</p>
                        <p>Optimize distribution</p>
                    </div>
                    <div class="card">
                        <h3>üéÆ Game AI</h3>
                        <p><strong>Algorithm:</strong> A*, DFS</p>
                        <p>Positions = vertices, moves = edges</p>
                        <p>Pathfinding, decision trees</p>
                    </div>
                    <div class="card">
                        <h3>üí° Circuit Design</h3>
                        <p><strong>Algorithm:</strong> MST, Bipartite Matching</p>
                        <p>Components = vertices, wires = edges</p>
                        <p>Minimize wire length</p>
                    </div>
                    <div class="card">
                        <h3>üß¨ Molecular Biology</h3>
                        <p><strong>Algorithm:</strong> DFS, Connected Components</p>
                        <p>Atoms = vertices, bonds = edges</p>
                        <p>Analyze molecular structures</p>
                    </div>
                </div>
            </div>
            
            <!-- COMMON PATTERNS -->
            <div class="section">
                <h2>üéØ Common Graph Problem Patterns</h2>
                
                <div class="algorithm-box">
                    <h3>Pattern 1: Finding Shortest Path</h3>
                    <p><strong>When:</strong> Minimize distance/cost/time</p>
                    <ul>
                        <li><strong>Unweighted:</strong> Use BFS</li>
                        <li><strong>Weighted (non-negative):</strong> Use Dijkstra's</li>
                        <li><strong>Weighted (negative):</strong> Use Bellman-Ford</li>
                        <li><strong>All pairs:</strong> Use Floyd-Warshall</li>
                    </ul>
                </div>
                
                <div class="algorithm-box">
                    <h3>Pattern 2: Detecting Cycles</h3>
                    <p><strong>When:</strong> Check for circular dependencies</p>
                    <ul>
                        <li><strong>Undirected:</strong> DFS with parent tracking or Union-Find</li>
                        <li><strong>Directed:</strong> DFS with 3-color marking</li>
                        <li><strong>In topological sort:</strong> Kahn's algorithm</li>
                    </ul>
                </div>
                
                <div class="algorithm-box">
                    <h3>Pattern 3: Finding Connected Regions</h3>
                    <p><strong>When:</strong> Group related elements</p>
                    <ul>
                        <li><strong>Count components:</strong> DFS/BFS on unvisited nodes</li>
                        <li><strong>Island counting:</strong> DFS on 2D grid</li>
                        <li><strong>Disjoint sets:</strong> Union-Find</li>
                    </ul>
                </div>
                
                <div class="algorithm-box">
                    <h3>Pattern 4: Ordering Tasks</h3>
                    <p><strong>When:</strong> Dependencies, prerequisites</p>
                    <ul>
                        <li><strong>Valid ordering:</strong> Topological sort (DFS or Kahn's)</li>
                        <li><strong>Check if possible:</strong> Detect cycles first</li>
                        <li><strong>Course schedule:</strong> Classic DAG problem</li>
                    </ul>
                </div>
                
                <div class="algorithm-box">
                    <h3>Pattern 5: Minimum Spanning Network</h3>
                    <p><strong>When:</strong> Connect all nodes with minimum cost</p>
                    <ul>
                        <li><strong>Sparse graph:</strong> Kruskal's with Union-Find</li>
                        <li><strong>Dense graph:</strong> Prim's with min-heap</li>
                        <li><strong>Always:</strong> Greedy approach works!</li>
                    </ul>
                </div>
                
                <div class="algorithm-box">
                    <h3>Pattern 6: Graph Coloring</h3>
                    <p><strong>When:</strong> Assign categories with constraints</p>
                    <ul>
                        <li><strong>2-coloring:</strong> Check bipartite with BFS</li>
                        <li><strong>No adjacent same color:</strong> Classic coloring</li>
                        <li><strong>Scheduling conflicts:</strong> Model as graph coloring</li>
                    </ul>
                </div>
            </div>
            
            <!-- INTERVIEW TIPS -->
            <div class="section">
                <h2>üìù Interview Tips & Common Questions</h2>
                
                <div class="highlight-box">
                    <h4>üéì Must-Know for Interviews:</h4>
                    <ol>
                        <li><strong>Graph representations:</strong> Adjacency list, matrix, edge list</li>
                        <li><strong>BFS & DFS:</strong> Both recursive and iterative</li>
                        <li><strong>Dijkstra's algorithm:</strong> With min-heap</li>
                        <li><strong>Cycle detection:</strong> Both directed and undirected</li>
                        <li><strong>Topological sort:</strong> DFS and Kahn's algorithm</li>
                        <li><strong>Union-Find:</strong> With path compression and union by rank</li>
                        <li><strong>Connected components:</strong> Count and find</li>
                        <li><strong>Bipartite check:</strong> 2-coloring approach</li>
                    </ol>
                </div>
                
                <div class="info-box">
                    <h4>üí° Top Interview Questions:</h4>
                    <ol>
                        <li><strong>Number of Islands</strong> - DFS/BFS on 2D grid</li>
                        <li><strong>Course Schedule</strong> - Cycle detection, topological sort</li>
                        <li><strong>Clone Graph</strong> - DFS/BFS with hashmap</li>
                        <li><strong>Word Ladder</strong> - BFS shortest path</li>
                        <li><strong>Network Delay Time</strong> - Dijkstra's algorithm</li>
                        <li><strong>Minimum Spanning Tree</strong> - Kruskal's or Prim's</li>
                        <li><strong>Alien Dictionary</strong> - Topological sort</li>
                        <li><strong>Graph Valid Tree</strong> - Cycle detection + connectivity</li>
                        <li><strong>Reconstruct Itinerary</strong> - Eulerian path</li>
                        <li><strong>Critical Connections</strong> - Find bridges</li>
                    </ol>
                </div>
                
                <div class="warning-box">
                    <h4>‚ö†Ô∏è Common Pitfalls:</h4>
                    <ul>
                        <li><strong>Forgetting to mark visited:</strong> Leads to infinite loops</li>
                        <li><strong>Wrong cycle detection:</strong> Need different logic for directed vs undirected</li>
                        <li><strong>Not handling disconnected graphs:</strong> Process all components</li>
                        <li><strong>Using wrong algorithm:</strong> Dijkstra won't work with negative weights</li>
                        <li><strong>Space complexity:</strong> Remember visited set takes O(V) space</li>
                        <li><strong>Edge cases:</strong> Empty graph, single node, no edges</li>
                    </ul>
                </div>
                
                <div class="highlight-box">
                    <h4>üéØ Problem-Solving Framework:</h4>
                    <ol>
                        <li><strong>Identify graph type:</strong> Directed? Weighted? Cyclic?</li>
                        <li><strong>Choose representation:</strong> Matrix for dense, list for sparse</li>
                        <li><strong>Pick algorithm:</strong> Match problem pattern to algorithm</li>
                        <li><strong>Handle edge cases:</strong> Empty, single node, disconnected</li>
                        <li><strong>Optimize:</strong> Can you reduce time/space?</li>
                        <li><strong>Test thoroughly:</strong> Draw examples, trace through</li>
                    </ol>
                </div>
            </div>
            
            <!-- BEST PRACTICES -->
            <div class="section">
                <h2>‚úÖ Best Practices & Code Quality</h2>
                
                <div class="comparison-grid">
                    <div class="card">
                        <h3>Choose Right Representation</h3>
                        <p><strong>Adjacency List:</strong> 90% of cases</p>
                        <p><strong>Matrix:</strong> Dense graphs, quick edge lookup</p>
                        <p><strong>Edge List:</strong> MST algorithms</p>
                    </div>
                    <div class="card">
                        <h3>Always Handle Disconnected</h3>
                        <p>Loop through all vertices as potential starting points</p>
                        <p>Don't assume connected graph</p>
                    </div>
                    <div class="card">
                        <h3>Use Visited Set</h3>
                        <p>Prevent infinite loops and duplicate work</p>
                        <p>Essential for cycle detection</p>
                    </div>
                    <div class="card">
                        <h3>Document Complexity</h3>
                        <p>Always mention time and space</p>
                        <p>Explain why certain DS was chosen</p>
                    </div>
                    <div class="card">
                        <h3>Test Edge Cases</h3>
                        <p>Empty graph, single node</p>
                        <p>Disconnected, cyclic, DAG</p>
                    </div>
                    <div class="card">
                        <h3>Consider Both Approaches</h3>
                        <p>BFS vs DFS tradeoffs</p>
                        <p>Iterative vs recursive</p>
                    </div>
                </div>
                
                <div class="highlight-box" style="margin-top: 30px;">
                    <h4>üîß Code Organization Tips:</h4>
                    <ul>
                        <li>Use meaningful variable names: <code>visited</code>, <code>queue</code>, <code>distances</code></li>
                        <li>Separate concerns: Build graph, then run algorithm</li>
                        <li>Add comments for complex logic (especially cycle detection)</li>
                        <li>Use helper functions for DFS/BFS to keep main function clean</li>
                        <li>Consider creating Graph class for reusable operations</li>
                    </ul>
                </div>
            </div>
            
            <!-- QUICK REFERENCE -->
            <div class="section">
                <h2>üìã Quick Reference Cheat Sheet</h2>
                
                <div class="algorithm-box">
                    <h3>When to Use What?</h3>
                    <table style="margin-top: 15px;">
                        <tr>
                            <th>Problem Type</th>
                            <th>Algorithm/Technique</th>
                        </tr>
                        <tr>
                            <td>Shortest path (unweighted)</td>
                            <td>BFS</td>
                        </tr>
                        <tr>
                            <td>Shortest path (weighted, non-negative)</td>
                            <td>Dijkstra's</td>
                        </tr>
                        <tr>
                            <td>Shortest path (negative weights)</td>
                            <td>Bellman-Ford</td>
                        </tr>
                        <tr>
                            <td>All pairs shortest path</td>
                            <td>Floyd-Warshall</td>
                        </tr>
                        <tr>
                            <td>Minimum spanning tree</td>
                            <td>Kruskal's or Prim's</td>
                        </tr>
                        <tr>
                            <td>Topological ordering</td>
                            <td>DFS or Kahn's (BFS)</td>
                        </tr>
                        <tr>
                            <td>Cycle detection (undirected)</td>
                            <td>DFS with parent or Union-Find</td>
                        </tr>
                        <tr>
                            <td>Cycle detection (directed)</td>
                            <td>DFS with 3-color</td>
                        </tr>
                        <tr>
                            <td>Connected components</td>
                            <td>DFS or BFS</td>
                        </tr>
                        <tr>
                            <td>Bipartite check</td>
                            <td>BFS/DFS 2-coloring</td>
                        </tr>
                        <tr>
                            <td>Strongly connected components</td>
                            <td>Kosaraju's or Tarjan's</td>
                        </tr>
                        <tr>
                            <td>Find bridges</td>
                            <td>Tarjan's algorithm</td>
                        </tr>
                        <tr>
                            <td>Level-order traversal</td>
                            <td>BFS</td>
                        </tr>
                        <tr>
                            <td>Explore all paths</td>
                            <td>DFS with backtracking</td>
                        </tr>
                    </table>
                </div>
                
                <div class="code-block" style="margin-top: 30px;"><span class="comment"># Essential Graph Template</span>

<span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict, deque
<span class="keyword">import</span> heapq

<span class="keyword">class</span> <span class="function">Graph</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.graph = defaultdict(list)
    
    <span class="keyword">def</span> <span class="function">add_edge</span>(self, u, v, weight=1):
        self.graph[u].append((v, weight))
        <span class="comment"># For undirected: self.graph[v].append((u, weight))</span>
    
    <span class="keyword">def</span> <span class="function">bfs</span>(self, start):
        visited = set([start])
        queue = deque([start])
        result = []
        
        <span class="keyword">while</span> queue:
            vertex = queue.popleft()
            result.append(vertex)
            <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> self.graph[vertex]:
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        <span class="keyword">return</span> result
    
    <span class="keyword">def</span> <span class="function">dfs</span>(self, start, visited=None):
        <span class="keyword">if</span> visited <span class="keyword">is None</span>:
            visited = set()
        visited.add(start)
        result = [start]
        
        <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> self.graph[start]:
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                result.extend(self.dfs(neighbor, visited))
        <span class="keyword">return</span> result

<span class="comment"># Quick usage</span>
g = Graph()
g.add_edge(0, 1)
g.add_edge(0, 2)
print(g.bfs(0))  <span class="comment"># BFS traversal</span>
print(g.dfs(0))  <span class="comment"># DFS traversal</span></div>
            </div>
            
            <!-- NEXT STEPS -->
            <div class="section">
                <h2>üöÄ Next Steps in Your Learning Journey</h2>
                
                <div class="comparison-grid">
                    <div class="card">
                        <h3>1. Master the Basics</h3>
                        <p>‚ú¶ Implement BFS and DFS from scratch</p>
                        <p>‚ú¶ Solve 20+ easy graph problems</p>
                        <p>‚ú¶ Practice both representations</p>
                    </div>
                    <div class="card">
                        <h3>2. Core Algorithms</h3>
                        <p>‚ú¶ Dijkstra's with min-heap</p>
                        <p>‚ú¶ Topological sort both ways</p>
                        <p>‚ú¶ Union-Find with optimizations</p>
                    </div>
                    <div class="card">
                        <h3>3. Advanced Topics</h3>
                        <p>‚ú¶ Network Flow (Max-Flow)</p>
                        <p>‚ú¶ A* pathfinding</p>
                        <p>‚ú¶ Eulerian/Hamiltonian paths</p>
                    </div>
                    <div class="card">
                        <h3>4. Real Projects</h3>
                        <p>‚ú¶ Build a route planner</p>
                        <p>‚ú¶ Social network analyzer</p>
                        <p>‚ú¶ Dependency resolver</p>
                    </div>
                </div>
                
                <div class="highlight-box" style="margin-top: 30px;">
                    <h4>üìö Practice Resources:</h4>
                    <ul>
                        <li><strong>LeetCode:</strong> Graph tag (150+ problems), explore card</li>
                        <li><strong>Codeforces:</strong> Graph theory section</li>
                        <li><strong>HackerRank:</strong> Graph challenges</li>
                        <li><strong>GeeksforGeeks:</strong> Comprehensive tutorials</li>
                        <li><strong>Visualgo:</strong> Algorithm visualizations</li>
                    </ul>
                </div>
            </div>
            
            <!-- SUMMARY -->
            <div class="section">
                <h2>üéì Key Takeaways</h2>
                <div style="background: white; padding: 30px; border-radius: 12px; font-size: 1.05em; line-height: 2;">
                    <p>
                        ‚ú¶ <strong>Graphs are everywhere:</strong> Most real-world problems involve relationships = graphs<br>
                        ‚ú¶ <strong>Two main traversals:</strong> BFS (level-by-level) and DFS (depth-first)<br>
                        ‚ú¶ <strong>Representation matters:</strong> Adjacency list for 90% of problems<br>
                        ‚ú¶ <strong>Know your algorithms:</strong> Dijkstra (non-negative), Bellman-Ford (negative), BFS (unweighted)<br>
                        ‚ú¶ <strong>Directed vs Undirected:</strong> Different cycle detection, topological sort only for DAG<br>
                        ‚ú¶ <strong>Always handle visited:</strong> Prevent infinite loops and track progress<br>
                        ‚ú¶ <strong>Pattern recognition:</strong> Map problem to known algorithm pattern<br>
                        ‚ú¶ <strong>Practice is key:</strong> Graphs need more practice than trees - start solving!
                    </p>
                </div>
                
                <div class="highlight-box" style="margin-top: 30px; text-align: center;">
                    <h3 style="margin-bottom: 15px;">üéØ Remember</h3>
                    <p style="font-size: 1.2em; font-style: italic;">
                        "Graphs may seem complex at first, but they're just trees that grew up and made friends with their siblings!"
                    </p>
                    <p style="margin-top: 20px; font-weight: bold; color: #667eea;">
                        Keep practicing, visualize problems, and soon graphs will become your superpower! üí™
                    </p>
                </div>
            </div>
        </div>
    </div>
</body>
</html>