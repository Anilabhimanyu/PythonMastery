<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>All Sorting Algorithms - Complete Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 50%, #45B7D1 100%);
            color: #333;
            padding: 20px;
            line-height: 1.7;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 50%, #45B7D1 100%);
            color: white;
            padding: 50px;
            text-align: center;
        }
        
        h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .subtitle {
            font-size: 1.3em;
            opacity: 0.95;
        }
        
        nav {
            background: #f8f9fa;
            padding: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .nav-links {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .nav-links a {
            padding: 10px 20px;
            background: white;
            color: #FF6B6B;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .nav-links a:hover {
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);
            color: white;
            transform: translateY(-2px);
        }
        
        .content {
            padding: 50px;
        }
        
        .section {
            margin-bottom: 50px;
            padding: 40px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 6px solid #FF6B6B;
        }
        
        h2 {
            color: #FF6B6B;
            margin-bottom: 25px;
            font-size: 2.2em;
            border-bottom: 3px solid #FF6B6B;
            padding-bottom: 10px;
        }
        
        h3 {
            color: #4ECDC4;
            margin: 25px 0 15px 0;
            font-size: 1.6em;
        }
        
        h4 {
            color: #45B7D1;
            margin: 20px 0 10px 0;
            font-size: 1.3em;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 25px;
            border-radius: 12px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.6;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            white-space: pre;
        }
        
        .code-block .comment {
            color: #95a5a6;
        }
        
        .code-block .keyword {
            color: #3498db;
        }
        
        .code-block .string {
            color: #e74c3c;
        }
        
        .code-block .function {
            color: #f39c12;
        }
        
        .visual-flow {
            background: white;
            padding: 25px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
        }
        
        .visual-flow pre {
            margin: 10px 0;
            line-height: 1.8;
        }
        
        .step {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #FF6B6B;
            border-radius: 4px;
        }
        
        .step-title {
            font-weight: bold;
            color: #FF6B6B;
            margin-bottom: 10px;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .card {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            border-top: 4px solid #FF6B6B;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }
        
        .highlight-box {
            background: linear-gradient(135deg, #ffe5e5 0%, #e5f7f6 100%);
            border-left: 5px solid #FF6B6B;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .warning-box {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .info-box {
            background: #d1ecf1;
            border-left: 5px solid #17a2b8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .success-box {
            background: #d4edda;
            border-left: 5px solid #28a745;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        
        th {
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 15px;
            border-bottom: 1px solid #ecf0f1;
        }
        
        tr:hover {
            background: #f8f9fa;
        }
        
        code {
            background: #f4f4f4;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #e74c3c;
            font-size: 0.9em;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-top: 15px;
        }
        
        li {
            margin: 10px 0;
        }
        
        strong {
            color: #FF6B6B;
        }
        
        .array-viz {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }
        
        .array-item {
            padding: 8px 12px;
            background: #4ECDC4;
            color: white;
            border-radius: 4px;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
        }
        
        .array-item.highlight {
            background: #FF6B6B;
        }
        
        .array-item.sorted {
            background: #28a745;
        }
        
        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }
            
            .section {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîÑ All Sorting Algorithms</h1>
            <p class="subtitle">Complete Guide with Visual Flow Demonstrations</p>
        </header>
        
        <nav>
            <div class="nav-links">
                <a href="#overview">Overview</a>
                <a href="#bubble">Bubble Sort</a>
                <a href="#selection">Selection Sort</a>
                <a href="#insertion">Insertion Sort</a>
                <a href="#merge">Merge Sort</a>
                <a href="#quick">Quick Sort</a>
                <a href="#heap">Heap Sort</a>
                <a href="#comparison">Comparison</a>
            </div>
        </nav>
        
        <div class="content">
            <!-- OVERVIEW -->
            <div class="section" id="overview">
                <h2>üìä Sorting Algorithms Overview</h2>
                <p>Sorting is the process of arranging data in a particular order (ascending or descending). Here's every major sorting algorithm you need to know!</p>
                
                <h3>Quick Comparison Table</h3>
                <table>
                    <tr>
                        <th>Algorithm</th>
                        <th>Best</th>
                        <th>Average</th>
                        <th>Worst</th>
                        <th>Space</th>
                        <th>Stable?</th>
                        <th>In-Place?</th>
                    </tr>
                    <tr>
                        <td><strong>Bubble Sort</strong></td>
                        <td>O(n)</td>
                        <td>O(n¬≤)</td>
                        <td>O(n¬≤)</td>
                        <td>O(1)</td>
                        <td>‚úÖ Yes</td>
                        <td>‚úÖ Yes</td>
                    </tr>
                    <tr>
                        <td><strong>Selection Sort</strong></td>
                        <td>O(n¬≤)</td>
                        <td>O(n¬≤)</td>
                        <td>O(n¬≤)</td>
                        <td>O(1)</td>
                        <td>‚ùå No</td>
                        <td>‚úÖ Yes</td>
                    </tr>
                    <tr>
                        <td><strong>Insertion Sort</strong></td>
                        <td>O(n)</td>
                        <td>O(n¬≤)</td>
                        <td>O(n¬≤)</td>
                        <td>O(1)</td>
                        <td>‚úÖ Yes</td>
                        <td>‚úÖ Yes</td>
                    </tr>
                    <tr>
                        <td><strong>Merge Sort</strong></td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n)</td>
                        <td>‚úÖ Yes</td>
                        <td>‚ùå No</td>
                    </tr>
                    <tr>
                        <td><strong>Quick Sort</strong></td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n¬≤)</td>
                        <td>O(log n)</td>
                        <td>‚ùå No</td>
                        <td>‚úÖ Yes</td>
                    </tr>
                    <tr>
                        <td><strong>Heap Sort</strong></td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(1)</td>
                        <td>‚ùå No</td>
                        <td>‚úÖ Yes</td>
                    </tr>
                </table>
                
                <div class="highlight-box">
                    <h4>üéØ Key Terminology:</h4>
                    <ul>
                        <li><strong>Stable:</strong> Maintains relative order of equal elements</li>
                        <li><strong>In-Place:</strong> Uses O(1) extra space (sorts within original array)</li>
                        <li><strong>Adaptive:</strong> Performance improves if array is partially sorted</li>
                        <li><strong>Comparison-based:</strong> Uses comparisons to determine order</li>
                    </ul>
                </div>
            </div>
            
            <!-- BUBBLE SORT -->
            <div class="section" id="bubble">
                <h2>1Ô∏è‚É£ Bubble Sort</h2>
                <p>Repeatedly swaps adjacent elements if they're in wrong order. Largest element "bubbles up" to end each pass.</p>
                
                <h3>üìñ How It Works</h3>
                <p>Compare adjacent elements and swap if left > right. After each pass, the largest unsorted element reaches its final position.</p>
                
                <div class="visual-flow">
                    <h4>Visual Flow: Sorting [64, 34, 25, 12, 22]</h4>
                    <pre>
<strong>Initial Array:</strong>
[64, 34, 25, 12, 22]

<strong>Pass 1:</strong>
[64, 34, 25, 12, 22]  ‚Üí Compare 64 & 34, swap
[34, 64, 25, 12, 22]  ‚Üí Compare 64 & 25, swap
[34, 25, 64, 12, 22]  ‚Üí Compare 64 & 12, swap
[34, 25, 12, 64, 22]  ‚Üí Compare 64 & 22, swap
[34, 25, 12, 22, <span style="color: #28a745;">64</span>]  ‚Üí 64 in correct position!

<strong>Pass 2:</strong>
[34, 25, 12, 22, <span style="color: #28a745;">64</span>]  ‚Üí Compare 34 & 25, swap
[25, 34, 12, 22, <span style="color: #28a745;">64</span>]  ‚Üí Compare 34 & 12, swap
[25, 12, 34, 22, <span style="color: #28a745;">64</span>]  ‚Üí Compare 34 & 22, swap
[25, 12, 22, <span style="color: #28a745;">34, 64</span>]  ‚Üí 34 in correct position!

<strong>Pass 3:</strong>
[25, 12, 22, <span style="color: #28a745;">34, 64</span>]  ‚Üí Compare 25 & 12, swap
[12, 25, 22, <span style="color: #28a745;">34, 64</span>]  ‚Üí Compare 25 & 22, swap
[12, 22, <span style="color: #28a745;">25, 34, 64</span>]  ‚Üí 25 in correct position!

<strong>Pass 4:</strong>
[12, 22, <span style="color: #28a745;">25, 34, 64</span>]  ‚Üí Compare 12 & 22, no swap
[<span style="color: #28a745;">12, 22, 25, 34, 64</span>]  ‚Üí Array sorted!
                    </pre>
                </div>
                
                <h3>üíª Implementation</h3>
<div class="code-block"><span class="keyword">def</span> <span class="function">bubble_sort</span>(arr):
    <span class="comment">"""
    Bubble Sort - O(n¬≤) time, O(1) space
    Stable: Yes, In-place: Yes
    """</span>
    n = len(arr)
    
    <span class="comment"># Traverse through all array elements</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
        swapped = <span class="keyword">False</span>
        
        <span class="comment"># Last i elements are already sorted</span>
        <span class="keyword">for</span> j <span class="keyword">in</span> range(0, n - i - 1):
            <span class="comment"># Swap if element found is greater than next</span>
            <span class="keyword">if</span> arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = <span class="keyword">True</span>
        
        <span class="comment"># If no swaps, array is sorted</span>
        <span class="keyword">if not</span> swapped:
            <span class="keyword">break</span>
    
    <span class="keyword">return</span> arr

<span class="comment"># Test</span>
arr = [64, 34, 25, 12, 22]
print(bubble_sort(arr))  <span class="comment"># Output: [12, 22, 25, 34, 64]</span></div>

                <div class="comparison-grid">
                    <div class="card">
                        <h3>‚úÖ Advantages</h3>
                        <ul>
                            <li>Simple to understand and implement</li>
                            <li>Stable sorting algorithm</li>
                            <li>In-place (no extra space)</li>
                            <li>Adaptive (O(n) if already sorted)</li>
                            <li>Good for small datasets</li>
                        </ul>
                    </div>
                    <div class="card">
                        <h3>‚ùå Disadvantages</h3>
                        <ul>
                            <li>Very slow - O(n¬≤)</li>
                            <li>Not efficient for large datasets</li>
                            <li>More swaps than other algorithms</li>
                            <li>Rarely used in practice</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- SELECTION SORT -->
            <div class="section" id="selection">
                <h2>2Ô∏è‚É£ Selection Sort</h2>
                <p>Finds the minimum element and places it at the beginning. Divides array into sorted and unsorted regions.</p>
                
                <h3>üìñ How It Works</h3>
                <p>Find minimum element in unsorted region and swap with first unsorted element. Repeat until sorted.</p>
                
                <div class="visual-flow">
                    <h4>Visual Flow: Sorting [64, 25, 12, 22, 11]</h4>
                    <pre>
<strong>Initial Array:</strong>
[64, 25, 12, 22, 11]
 ‚Üë unsorted region

<strong>Pass 1:</strong> Find minimum (11) in unsorted region
[64, 25, 12, 22, <span style="color: #FF6B6B;">11</span>]  ‚Üí Min = 11, swap with position 0
[<span style="color: #28a745;">11</span>, 25, 12, 22, 64]  ‚Üí 11 sorted!
 ‚Üë     ‚Üë unsorted region

<strong>Pass 2:</strong> Find minimum (12) in unsorted region
[<span style="color: #28a745;">11</span>, 25, <span style="color: #FF6B6B;">12</span>, 22, 64]  ‚Üí Min = 12, swap with position 1
[<span style="color: #28a745;">11, 12</span>, 25, 22, 64]  ‚Üí 12 sorted!
 ‚Üë      ‚Üë unsorted region

<strong>Pass 3:</strong> Find minimum (22) in unsorted region
[<span style="color: #28a745;">11, 12</span>, 25, <span style="color: #FF6B6B;">22</span>, 64]  ‚Üí Min = 22, swap with position 2
[<span style="color: #28a745;">11, 12, 22</span>, 25, 64]  ‚Üí 22 sorted!
 ‚Üë          ‚Üë unsorted region

<strong>Pass 4:</strong> Find minimum (25) in unsorted region
[<span style="color: #28a745;">11, 12, 22</span>, <span style="color: #FF6B6B;">25</span>, 64]  ‚Üí Min = 25, no swap needed
[<span style="color: #28a745;">11, 12, 22, 25</span>, 64]  ‚Üí 25 sorted!

<strong>Pass 5:</strong> Only one element left
[<span style="color: #28a745;">11, 12, 22, 25, 64</span>]  ‚Üí Array sorted!
                    </pre>
                </div>
                
                <h3>üíª Implementation</h3>
<div class="code-block"><span class="keyword">def</span> <span class="function">selection_sort</span>(arr):
    <span class="comment">"""
    Selection Sort - O(n¬≤) time, O(1) space
    Stable: No, In-place: Yes
    """</span>
    n = len(arr)
    
    <span class="comment"># Traverse through all array elements</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
        <span class="comment"># Find minimum element in unsorted region</span>
        min_idx = i
        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + 1, n):
            <span class="keyword">if</span> arr[j] < arr[min_idx]:
                min_idx = j
        
        <span class="comment"># Swap minimum with first unsorted element</span>
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    <span class="keyword">return</span> arr

<span class="comment"># Test</span>
arr = [64, 25, 12, 22, 11]
print(selection_sort(arr))  <span class="comment"># Output: [11, 12, 22, 25, 64]</span></div>

                <div class="comparison-grid">
                    <div class="card">
                        <h3>‚úÖ Advantages</h3>
                        <ul>
                            <li>Simple to implement</li>
                            <li>In-place sorting</li>
                            <li>Minimum number of swaps (O(n))</li>
                            <li>Works well on small arrays</li>
                            <li>Performance not affected by input</li>
                        </ul>
                    </div>
                    <div class="card">
                        <h3>‚ùå Disadvantages</h3>
                        <ul>
                            <li>Slow - O(n¬≤) always</li>
                            <li>Not stable</li>
                            <li>Not adaptive (no benefit if sorted)</li>
                            <li>Poor cache performance</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- INSERTION SORT -->
            <div class="section" id="insertion">
                <h2>3Ô∏è‚É£ Insertion Sort</h2>
                <p>Builds sorted array one element at a time by inserting each element into its correct position.</p>
                
                <h3>üìñ How It Works</h3>
                <p>Like sorting playing cards - pick each card and insert it in the correct position in the sorted hand.</p>
                
                <div class="visual-flow">
                    <h4>Visual Flow: Sorting [12, 11, 13, 5, 6]</h4>
                    <pre>
<strong>Initial Array:</strong>
[12, 11, 13, 5, 6]
 ‚Üë sorted

<strong>Pass 1:</strong> Insert 11 into sorted region
[<span style="color: #28a745;">12</span>, <span style="color: #FF6B6B;">11</span>, 13, 5, 6]  ‚Üí 11 < 12, shift 12 right
[<span style="color: #FF6B6B;">11</span>, 12, 13, 5, 6]  ‚Üí Insert 11 at position 0
[<span style="color: #28a745;">11, 12</span>, 13, 5, 6]

<strong>Pass 2:</strong> Insert 13 into sorted region
[<span style="color: #28a745;">11, 12</span>, <span style="color: #FF6B6B;">13</span>, 5, 6]  ‚Üí 13 > 12, already in place
[<span style="color: #28a745;">11, 12, 13</span>, 5, 6]

<strong>Pass 3:</strong> Insert 5 into sorted region
[<span style="color: #28a745;">11, 12, 13</span>, <span style="color: #FF6B6B;">5</span>, 6]  ‚Üí 5 < 13, shift 13
[<span style="color: #28a745;">11, 12</span>, 13, 13, 6]  ‚Üí 5 < 12, shift 12
[<span style="color: #28a745;">11</span>, 12, 12, 13, 6]  ‚Üí 5 < 11, shift 11
[11, 11, 12, 13, 6]  ‚Üí Insert 5 at position 0
[<span style="color: #28a745;">5, 11, 12, 13</span>, 6]

<strong>Pass 4:</strong> Insert 6 into sorted region
[<span style="color: #28a745;">5, 11, 12, 13</span>, <span style="color: #FF6B6B;">6</span>]  ‚Üí 6 < 13, shift 13
[<span style="color: #28a745;">5, 11, 12</span>, 13, 13]  ‚Üí 6 < 12, shift 12
[<span style="color: #28a745;">5, 11</span>, 12, 12, 13]  ‚Üí 6 < 11, shift 11
[<span style="color: #28a745;">5</span>, 11, 11, 12, 13]  ‚Üí Insert 6 at position 1
[<span style="color: #28a745;">5, 6, 11, 12, 13</span>]  ‚Üí Array sorted!
                    </pre>
                </div>
                
                <h3>üíª Implementation</h3>
<div class="code-block"><span class="keyword">def</span> <span class="function">insertion_sort</span>(arr):
    <span class="comment">"""
    Insertion Sort - O(n¬≤) time, O(1) space
    Stable: Yes, In-place: Yes, Adaptive: Yes
    """</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, len(arr)):
        key = arr[i]  <span class="comment"># Element to be inserted</span>
        j = i - 1
        
        <span class="comment"># Move elements greater than key one position ahead</span>
        <span class="keyword">while</span> j >= 0 <span class="keyword">and</span> arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        <span class="comment"># Insert key at correct position</span>
        arr[j + 1] = key
    
    <span class="keyword">return</span> arr

<span class="comment"># Test</span>
arr = [12, 11, 13, 5, 6]
print(insertion_sort(arr))  <span class="comment"># Output: [5, 6, 11, 12, 13]</span></div>

                <div class="comparison-grid">
                    <div class="card">
                        <h3>‚úÖ Advantages</h3>
                        <ul>
                            <li>Simple and intuitive</li>
                            <li>Stable sorting</li>
                            <li>In-place sorting</li>
                            <li>Adaptive - O(n) if nearly sorted</li>
                            <li>Good for small datasets</li>
                            <li>Online algorithm (can sort as it receives data)</li>
                        </ul>
                    </div>
                    <div class="card">
                        <h3>‚ùå Disadvantages</h3>
                        <ul>
                            <li>Slow for large datasets - O(n¬≤)</li>
                            <li>Many shifts for reverse-sorted data</li>
                            <li>Not suitable for large arrays</li>
                        </ul>
                    </div>
                </div>
                
                <div class="success-box">
                    <h4>üéØ Best Use Cases:</h4>
                    <ul>
                        <li><strong>Small datasets</strong> (n < 50)</li>
                        <li><strong>Nearly sorted data</strong> - becomes O(n)</li>
                        <li><strong>Online sorting</strong> - data arrives over time</li>
                        <li><strong>Stable sort needed</strong> with<div class="success-box">
                    <h4>üéØ Best Use Cases:</h4>
                    <ul>
                        <li><strong>Small datasets</strong> (n < 50)</li>
                        <li><strong>Nearly sorted data</strong> - becomes O(n)</li>
                        <li><strong>Online sorting</strong> - data arrives over time</li>
                        <li><strong>Stable sort needed</strong> with small space</li>
                    </ul>
                </div>
            </div>
            
            <!-- MERGE SORT -->
            <div class="section" id="merge">
                <h2>4Ô∏è‚É£ Merge Sort</h2>
                <p>Divide and conquer algorithm. Divides array into halves, sorts them, then merges sorted halves.</p>
                
                <h3>üìñ How It Works</h3>
                <p>Recursively divide array until single elements, then merge them back in sorted order.</p>
                
                <div class="visual-flow">
                    <h4>Visual Flow: Sorting [38, 27, 43, 3, 9, 82, 10]</h4>
                    <pre>
<strong>DIVIDE PHASE (Splitting):</strong>

Level 0:    [38, 27, 43, 3, 9, 82, 10]
                      ‚Üì Split
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
Level 1:   [38, 27, 43, 3]    [9, 82, 10]
                ‚Üì                  ‚Üì Split
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê
Level 2:   [38, 27]  [43, 3]  [9, 82]  [10]
             ‚Üì         ‚Üì        ‚Üì
           ‚îå‚îÄ‚î¥‚îÄ‚îê     ‚îå‚îÄ‚î¥‚îÄ‚îê    ‚îå‚îÄ‚î¥‚îÄ‚îê
Level 3:   [38][27]  [43][3]  [9][82]  [10]

<strong>CONQUER PHASE (Merging):</strong>

Level 3:   [38][27]  [43][3]  [9][82]  [10]
             ‚Üì         ‚Üì        ‚Üì
           Merge     Merge    Merge
             ‚Üì         ‚Üì        ‚Üì
Level 2:   [27, 38]  [3, 43]  [9, 82]  [10]
                ‚Üì                  ‚Üì
              Merge              Merge
                ‚Üì                  ‚Üì
Level 1:   [3, 27, 38, 43]    [9, 10, 82]
                      ‚Üì Merge
Level 0:    [3, 9, 10, 27, 38, 43, 82]  ‚úì Sorted!

<strong>Detailed Merge Example (Level 2 ‚Üí Level 1):</strong>
Merging [27, 38] and [3, 43]:
  Compare 27 vs 3  ‚Üí Take 3     Result: [3]
  Compare 27 vs 43 ‚Üí Take 27    Result: [3, 27]
  Compare 38 vs 43 ‚Üí Take 38    Result: [3, 27, 38]
  Only 43 left    ‚Üí Take 43    Result: [3, 27, 38, 43]
                    </pre>
                </div>
                
                <h3>üíª Implementation</h3>
<div class="code-block"><span class="keyword">def</span> <span class="function">merge_sort</span>(arr):
    <span class="comment">"""
    Merge Sort - O(n log n) time, O(n) space
    Stable: Yes, In-place: No
    """</span>
    <span class="keyword">if</span> len(arr) <= 1:
        <span class="keyword">return</span> arr
    
    <span class="comment"># Divide: Find middle and split</span>
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    <span class="comment"># Conquer: Merge sorted halves</span>
    <span class="keyword">return</span> merge(left, right)

<span class="keyword">def</span> <span class="function">merge</span>(left, right):
    <span class="comment">"""Merge two sorted arrays"""</span>
    result = []
    i = j = 0
    
    <span class="comment"># Compare elements and add smaller one</span>
    <span class="keyword">while</span> i < len(left) <span class="keyword">and</span> j < len(right):
        <span class="keyword">if</span> left[i] <= right[j]:
            result.append(left[i])
            i += 1
        <span class="keyword">else</span>:
            result.append(right[j])
            j += 1
    
    <span class="comment"># Add remaining elements</span>
    result.extend(left[i:])
    result.extend(right[j:])
    
    <span class="keyword">return</span> result

<span class="comment"># Test</span>
arr = [38, 27, 43, 3, 9, 82, 10]
print(merge_sort(arr))  <span class="comment"># Output: [3, 9, 10, 27, 38, 43, 82]</span></div>

                <div class="comparison-grid">
                    <div class="card">
                        <h3>‚úÖ Advantages</h3>
                        <ul>
                            <li>Consistent O(n log n) performance</li>
                            <li>Stable sorting</li>
                            <li>Predictable - no worst case degradation</li>
                            <li>Good for large datasets</li>
                            <li>Parallelizable</li>
                            <li>Works well with linked lists</li>
                        </ul>
                    </div>
                    <div class="card">
                        <h3>‚ùå Disadvantages</h3>
                        <ul>
                            <li>Requires O(n) extra space</li>
                            <li>Not in-place</li>
                            <li>Slower than Quick Sort in practice</li>
                            <li>Overkill for small arrays</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- QUICK SORT -->
            <div class="section" id="quick">
                <h2>5Ô∏è‚É£ Quick Sort</h2>
                <p>Divide and conquer with partitioning. Choose pivot, partition around it, recursively sort partitions.</p>
                
                <h3>üìñ How It Works</h3>
                <p>Pick a pivot element, partition array so elements smaller than pivot are on left, larger on right. Recursively sort partitions.</p>
                
                <div class="visual-flow">
                    <h4>Visual Flow: Sorting [10, 7, 8, 9, 1, 5]</h4>
                    <pre>
<strong>Initial Array:</strong>
[10, 7, 8, 9, 1, 5]  Pivot = 5 (last element)

<strong>Partitioning Step 1:</strong>
[<span style="color: #FF6B6B;">10</span>, 7, 8, 9, 1, <span style="color: #4ECDC4;">5</span>]  i=-1, 10 > 5, don't move
[10, <span style="color: #FF6B6B;">7</span>, 8, 9, 1, <span style="color: #4ECDC4;">5</span>]  7 > 5, don't move
[10, 7, <span style="color: #FF6B6B;">8</span>, 9, 1, <span style="color: #4ECDC4;">5</span>]  8 > 5, don't move
[10, 7, 8, <span style="color: #FF6B6B;">9</span>, 1, <span style="color: #4ECDC4;">5</span>]  9 > 5, don't move
[10, 7, 8, 9, <span style="color: #FF6B6B;">1</span>, <span style="color: #4ECDC4;">5</span>]  1 < 5, i++, swap with arr[0]
[<span style="color: #28a745;">1</span>, 7, 8, 9, 10, <span style="color: #4ECDC4;">5</span>]  Place pivot at i+1
[<span style="color: #28a745;">1</span>, <span style="color: #4ECDC4;">5</span>, 8, 9, 10, 7]

After partition: [1] | <span style="color: #4ECDC4;">5</span> | [8, 9, 10, 7]
                  ‚Üë     ‚Üë         ‚Üë
                left  pivot    right

<strong>Recursively sort left side [1]:</strong>
[1]  ‚Üí Already sorted (single element)

<strong>Recursively sort right side [8, 9, 10, 7]:</strong>
Pivot = 7 (last element)
[8, 9, 10, <span style="color: #4ECDC4;">7</span>]  Partition:
  All elements > 7, so partition at start
[<span style="color: #4ECDC4;">7</span>, 9, 10, 8]

After partition: [] | <span style="color: #4ECDC4;">7</span> | [9, 10, 8]

<strong>Sort right subarray [9, 10, 8]:</strong>
Pivot = 8
[9, 10, <span style="color: #4ECDC4;">8</span>]  Partition:
  All elements > 8
[<span style="color: #4ECDC4;">8</span>, 10, 9]

After partition: [] | <span style="color: #4ECDC4;">8</span> | [10, 9]

<strong>Sort [10, 9]:</strong>
Pivot = 9
[10, <span style="color: #4ECDC4;">9</span>]  Partition:
  10 > 9, swap
[<span style="color: #4ECDC4;">9</span>, 10]

<strong>Final Result:</strong>
[<span style="color: #28a745;">1, 5, 7, 8, 9, 10</span>]  ‚úì Sorted!
                    </pre>
                </div>
                
                <h3>üíª Implementation</h3>
<div class="code-block"><span class="keyword">def</span> <span class="function">quick_sort</span>(arr, low=0, high=<span class="keyword">None</span>):
    <span class="comment">"""
    Quick Sort - O(n log n) average, O(n¬≤) worst
    Stable: No, In-place: Yes
    """</span>
    <span class="keyword">if</span> high <span class="keyword">is None</span>:
        high = len(arr) - 1
    
    <span class="keyword">if</span> low < high:
        <span class="comment"># Partition and get pivot index</span>
        pivot_idx = partition(arr, low, high)
        
        <span class="comment"># Recursively sort left and right of pivot</span>
        quick_sort(arr, low, pivot_idx - 1)
        quick_sort(arr, pivot_idx + 1, high)
    
    <span class="keyword">return</span> arr

<span class="keyword">def</span> <span class="function">partition</span>(arr, low, high):
    <span class="comment">"""Lomuto partition scheme"""</span>
    pivot = arr[high]  <span class="comment"># Choose last element as pivot</span>
    i = low - 1  <span class="comment"># Index of smaller element</span>
    
    <span class="keyword">for</span> j <span class="keyword">in</span> range(low, high):
        <span class="comment"># If current element <= pivot</span>
        <span class="keyword">if</span> arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    <span class="comment"># Place pivot in correct position</span>
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    <span class="keyword">return</span> i + 1

<span class="comment"># Test</span>
arr = [10, 7, 8, 9, 1, 5]
print(quick_sort(arr))  <span class="comment"># Output: [1, 5, 7, 8, 9, 10]</span></div>

                <h3>Pivot Selection Strategies</h3>
<div class="code-block"><span class="comment"># 1. Last element (shown above) - simple but worst case on sorted data</span>

<span class="comment"># 2. Random pivot - avoids worst case</span>
<span class="keyword">import</span> random
<span class="keyword">def</span> <span class="function">partition_random</span>(arr, low, high):
    rand_pivot = random.randint(low, high)
    arr[rand_pivot], arr[high] = arr[high], arr[rand_pivot]
    <span class="keyword">return</span> partition(arr, low, high)

<span class="comment"># 3. Median-of-three - good balance</span>
<span class="keyword">def</span> <span class="function">median_of_three</span>(arr, low, high):
    mid = (low + high) // 2
    <span class="keyword">if</span> arr[low] > arr[mid]:
        arr[low], arr[mid] = arr[mid], arr[low]
    <span class="keyword">if</span> arr[low] > arr[high]:
        arr[low], arr[high] = arr[high], arr[low]
    <span class="keyword">if</span> arr[mid] > arr[high]:
        arr[mid], arr[high] = arr[high], arr[mid]
    arr[mid], arr[high] = arr[high], arr[mid]
    <span class="keyword">return</span> partition(arr, low, high)</div>

                <div class="comparison-grid">
                    <div class="card">
                        <h3>‚úÖ Advantages</h3>
                        <ul>
                            <li>Fast in practice - O(n log n) average</li>
                            <li>In-place sorting</li>
                            <li>Cache-efficient</li>
                            <li>Fastest comparison-based sort on average</li>
                            <li>Low space overhead O(log n)</li>
                        </ul>
                    </div>
                    <div class="card">
                        <h3>‚ùå Disadvantages</h3>
                        <ul>
                            <li>Worst case O(n¬≤) on sorted data</li>
                            <li>Not stable</li>
                            <li>Pivot selection critical</li>
                            <li>Recursive (stack overflow risk)</li>
                        </ul>
                    </div>
                </div>
                
                <div class="warning-box">
                    <h4>‚ö†Ô∏è Worst Case Scenario:</h4>
                    <p>When pivot is always smallest or largest element (e.g., sorted array with last element as pivot):</p>
                    <ul>
                        <li>Partitions become extremely unbalanced (1 element vs n-1 elements)</li>
                        <li>Degrades to O(n¬≤) time complexity</li>
                        <li><strong>Solution:</strong> Use random pivot or median-of-three</li>
                    </ul>
                </div>
            </div>
            
            <!-- HEAP SORT -->
            <div class="section" id="heap">
                <h2>6Ô∏è‚É£ Heap Sort</h2>
                <p>Uses binary heap data structure. Build max-heap, then repeatedly extract maximum and rebuild heap.</p>
                
                <h3>üìñ How It Works</h3>
                <p>Convert array to max-heap, then repeatedly swap root (max) with last element and heapify reduced heap.</p>
                
                <div class="visual-flow">
                    <h4>Visual Flow: Sorting [4, 10, 3, 5, 1]</h4>
                    <pre>
<strong>Step 1: Build Max-Heap</strong>

Initial array: [4, 10, 3, 5, 1]

Tree representation:
       4
      / \
    10   3
    / \
   5   1

Heapify from bottom-up (start from last non-leaf node):

After heapifying index 1 (value 10):
       4
      / \
    10   3    ‚Üí 10 > 5, 10 > 1, OK
    / \
   5   1

After heapifying index 0 (value 4):
       4                  10
      / \        ‚Üí       / \
    10   3              4   3
    / \                / \
   5   1              5   1
   (4 < 10, swap)

Then heapify down:
      10                 10
      / \       ‚Üí       / \
    5   3              5   3
    / \                / \
   4   1              4   1
   (4 < 5, swap)

<strong>Max-Heap Built: [10, 5, 3, 4, 1]</strong>

<strong>Step 2: Extract Maximum and Heapify</strong>

Iteration 1:
[<span style="color: #FF6B6B;">10</span>, 5, 3, 4, <span style="color: #4ECDC4;">1</span>]  Swap 10 with last (1)
[<span style="color: #4ECDC4;">1</span>, 5, 3, 4, <span style="color: #28a745;">10</span>]  10 is sorted!
Heapify [1, 5, 3, 4]:
      1                  5
     / \       ‚Üí        / \
    5   3              4   3
   /                  /
  4                  1
Max-Heap: [5, 4, 3, 1]

Iteration 2:
[<span style="color: #FF6B6B;">5</span>, 4, 3, <span style="color: #4ECDC4;">1</span>, <span style="color: #28a745;">10</span>]  Swap 5 with last (1)
[<span style="color: #4ECDC4;">1</span>, 4, 3, <span style="color: #28a745;">5, 10</span>]  5 is sorted!
Heapify [1, 4, 3]:
      1                  4
     / \       ‚Üí        / \
    4   3              1   3
Max-Heap: [4, 1, 3]

Iteration 3:
[<span style="color: #FF6B6B;">4</span>, 1, <span style="color: #4ECDC4;">3</span>, <span style="color: #28a745;">5, 10</span>]  Swap 4 with last (3)
[<span style="color: #4ECDC4;">3</span>, 1, <span style="color: #28a745;">4, 5, 10</span>]  4 is sorted!
Heapify [3, 1]:
      3
     /         (Already max-heap)
    1

Iteration 4:
[<span style="color: #FF6B6B;">3</span>, <span style="color: #4ECDC4;">1</span>, <span style="color: #28a745;">4, 5, 10</span>]  Swap 3 with last (1)
[<span style="color: #4ECDC4;">1</span>, <span style="color: #28a745;">3, 4, 5, 10</span>]  3 is sorted!

<strong>Final Result: [<span style="color: #28a745;">1, 3, 4, 5, 10</span>]</strong>
                    </pre>
                </div>
                
                <h3>üíª Implementation</h3>
<div class="code-block"><span class="keyword">def</span> <span class="function">heap_sort</span>(arr):
    <span class="comment">"""
    Heap Sort - O(n log n) time, O(1) space
    Stable: No, In-place: Yes
    """</span>
    n = len(arr)
    
    <span class="comment"># Build max-heap</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    <span class="comment"># Extract elements from heap one by one</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - 1, 0, -1):
        <span class="comment"># Swap root (max) with last element</span>
        arr[0], arr[i] = arr[i], arr[0]
        
        <span class="comment"># Heapify reduced heap</span>
        heapify(arr, i, 0)
    
    <span class="keyword">return</span> arr

<span class="keyword">def</span> <span class="function">heapify</span>(arr, n, i):
    <span class="comment">"""Heapify subtree rooted at index i"""</span>
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    <span class="comment"># Check if left child exists and is greater</span>
    <span class="keyword">if</span> left < n <span class="keyword">and</span> arr[left] > arr[largest]:
        largest = left
    
    <span class="comment"># Check if right child exists and is greater</span>
    <span class="keyword">if</span> right < n <span class="keyword">and</span> arr[right] > arr[largest]:
        largest = right
    
    <span class="comment"># If largest is not root, swap and continue heapifying</span>
    <span class="keyword">if</span> largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

<span class="comment"># Test</span>
arr = [4, 10, 3, 5, 1]
print(heap_sort(arr))  <span class="comment"># Output: [1, 3, 4, 5, 10]</span></div>

                <div class="comparison-grid">
                    <div class="card">
                        <h3>‚úÖ Advantages</h3>
                        <ul>
                            <li>Consistent O(n log n) performance</li>
                            <li>In-place sorting</li>
                            <li>No worst case degradation</li>
                            <li>Good for priority queue implementation</li>
                            <li>Memory efficient</li>
                        </ul>
                    </div>
                    <div class="card">
                        <h3>‚ùå Disadvantages</h3>
                        <ul>
                            <li>Not stable</li>
                            <li>Not adaptive</li>
                            <li>Poor cache locality</li>
                            <li>Slower than Quick Sort in practice</li>
                            <li>Complex implementation</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- COMPREHENSIVE COMPARISON -->
            <div class="section" id="comparison">
                <h2>üìä Comprehensive Comparison</h2>
                
                <h3>Complete Complexity Table</h3>
                <table>
                    <tr>
                        <th>Algorithm</th>
                        <th>Best</th>
                        <th>Average</th>
                        <th>Worst</th>
                        <th>Space</th>
                        <th>Stable</th>
                        <th>In-Place</th>
                        <th>Adaptive</th>
                    </tr>
                    <tr>
                        <td><strong>Bubble Sort</strong></td>
                        <td>O(n)</td>
                        <td>O(n¬≤)</td>
                        <td>O(n¬≤)</td>
                        <td>O(1)</td>
                        <td>‚úÖ</td>
                        <td>‚úÖ</td>
                        <td>‚úÖ</td>
                    </tr>
                    <tr>
                        <td><strong>Selection Sort</strong></td>
                        <td>O(n¬≤)</td>
                        <td>O(n¬≤)</td>
                        <td>O(n¬≤)</td>
                        <td>O(1)</td>
                        <td>‚ùå</td>
                        <td>‚úÖ</td>
                        <td>‚ùå</td>
                    </tr>
                    <tr>
                        <td><strong>Insertion Sort</strong></td>
                        <td>O(n)</td>
                        <td>O(n¬≤)</td>
                        <td>O(n¬≤)</td>
                        <td>O(1)</td>
                        <td>‚úÖ</td>
                        <td>‚úÖ</td>
                        <td>‚úÖ</td>
                    </tr>
                    <tr>
                        <td><strong>Merge Sort</strong></td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n)</td>
                        <td>‚úÖ</td>
                        <td>‚ùå</td>
                        <td>‚ùå</td>
                    </tr>
                    <tr>
                        <td><strong>Quick Sort</strong></td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n¬≤)</td>
                        <td>O(log n)</td>
                        <td>‚ùå</td>
                        <td>‚úÖ</td>
                        <td>‚ùå</td>
                    </tr>
                    <tr>
                        <td><strong>Heap Sort</strong></td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(n log n)</td>
                        <td>O(1)</td>
                        <td>‚ùå</td>
                        <td>‚úÖ</td>
                        <td>‚ùå</td>
                    </tr>
                </table>
                
                <h3>When to Use Which Algorithm?</h3>
                <div class="comparison-grid">
                    <div class="card">
                        <h3>Bubble Sort</h3>
                        <p><strong>Use when:</strong></p>
                        <ul>
                            <li>Learning/teaching purposes</li>
                            <li>Very small datasets (n < 10)</li>
                            <li>Nearly sorted data</li>
                            <li>Simplicity is priority</li>
                        </ul>
                        <p><strong>Avoid when:</strong> Any production code!</p>
                    </div>
                    
                    <div class="card">
                        <h3>Selection Sort</h3>
                        <p><strong>Use when:</strong></p>
                        <ul>
                            <li>Memory writes are expensive</li>
                            <li>Need minimum swaps</li>
                            <li>Very small arrays</li>
                        </ul>
                        <p><strong>Avoid when:</strong> Need stable sort or large data</p>
                    </div>
                    
                    <div class="card">
                        <h3>Insertion Sort</h3>
                        <p><strong>Use when:</strong></p>
                        <ul>
                            <li>Small datasets (n < 50)</li>
                            <li>Nearly sorted data</li>
                            <li>Online sorting (streaming data)</li>
                            <li>Need stable + in-place</li>
                        </ul>
                        <p><strong>Best choice:</strong> Small or nearly sorted!</p>
                    </div>
                    
                    <div class="card">
                        <h3>Merge Sort</h3>
                        <p><strong>Use when:</strong></p>
                        <ul>
                            <li>Need stable sorting</li>
                            <li>Guaranteed O(n log n)</li>
                            <li>Sorting linked lists</li>
                            <li>External sorting (disk)</li>
                        </ul>
                        <p><strong>Trade-off:</strong> Needs O(n) space</p>
                    </div>
                    
                    <div class="card">
                        <h3>Quick Sort</h3>
                        <p><strong>Use when:</strong></p>
                        <ul>
                            <li>General purpose sorting</li>
                            <li>Average case performance matters</li>
                            <li>In-place needed</li>
                            <li>Default choice for most cases</li>
                        </ul>
                        <p><strong>Best choice:</strong> Most situations!</p>
                    </div>
                    
                    <div class="card">
                        <h3>Heap Sort</h3>
                        <p><strong>Use when:</strong></p>
                        <ul>
                            <li>Need O(n log n) worst case</li>
                            <li>Memory constrained (O(1) space)</li>
                            <li>Priority queue operations</li>
                        </ul>
                        <p><strong>Good for:</strong> Real-time systems</p>
                    </div>
                </div>
                
                <h3>Decision Tree</h3>
                <div class="visual-flow">
                    <pre>
                    Start: Need to sort?
                           |
                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                   |                |
              Small data?       Large data?
              (n < 50)          (n > 50)
                   |                |
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         |
              |          |         |
         Nearly     Random    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         sorted?    data?     |          |
              |          |    Need      No stability
         Insertion  Insertion stable?   needed?
         Sort       Sort      |          |
         O(n)       O(n¬≤)     |      ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê
                              |      |       |
                         Merge Sort  |    Memory OK?
                         O(n log n)  |       |
                         Space O(n)  |   ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ
                         
<!DOCTYPE html>
