<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Programming - Complete Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            padding: 20px;
            line-height: 1.7;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 50px;
            text-align: center;
        }
        
        h1 {
            font-size: 3em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.3em;
            opacity: 0.95;
        }
        
        nav {
            background: #f8f9fa;
            padding: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .nav-links {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .nav-links a {
            padding: 10px 20px;
            background: white;
            color: #667eea;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .nav-links a:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
        }
        
        .content {
            padding: 50px;
        }
        
        .section {
            margin-bottom: 50px;
            padding: 40px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 6px solid #667eea;
        }
        
        h2 {
            color: #667eea;
            margin-bottom: 25px;
            font-size: 2.2em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }
        
        h3 {
            color: #764ba2;
            margin: 25px 0 15px 0;
            font-size: 1.6em;
        }
        
        h4 {
            color: #5a67d8;
            margin: 20px 0 10px 0;
            font-size: 1.3em;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 25px;
            border-radius: 12px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.6;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            white-space: pre;
        }
        
        .code-block .comment {
            color: #95a5a6;
        }
        
        .code-block .keyword {
            color: #3498db;
        }
        
        .code-block .string {
            color: #e74c3c;
        }
        
        .code-block .function {
            color: #f39c12;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .card {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }
        
        .card h3 {
            margin-top: 0;
        }
        
        .highlight-box {
            background: #e3e8ff;
            border-left: 5px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .warning-box {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .info-box {
            background: #d1ecf1;
            border-left: 5px solid #17a2b8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .success-box {
            background: #d4edda;
            border-left: 5px solid #28a745;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        
        th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 15px;
            border-bottom: 1px solid #ecf0f1;
        }
        
        tr:hover {
            background: #f8f9fa;
        }
        
        code {
            background: #f4f4f4;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #e74c3c;
            font-size: 0.9em;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-top: 15px;
        }
        
        li {
            margin: 10px 0;
        }
        
        strong {
            color: #667eea;
        }
        
        .algorithm-box {
            background: white;
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
        }
        
        .visual-example {
            background: white;
            padding: 30px;
            border-radius: 15px;
            margin: 25px 0;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        
        .dp-table {
            display: inline-block;
            margin: 20px auto;
        }
        
        .dp-table table {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .dp-table td {
            text-align: center;
            min-width: 40px;
            font-weight: bold;
        }
        
        .dp-table .highlight {
            background: #e3e8ff !important;
        }
        
        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }
            
            .section {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>🎯 Dynamic Programming</h1>
            <p class="subtitle">Complete Guide: From Basics to Advanced Patterns</p>
        </header>
        
        <nav>
            <div class="nav-links">
                <a href="#basics">Basics</a>
                <a href="#characteristics">Characteristics</a>
                <a href="#approaches">Approaches</a>
                <a href="#1d-dp">1D DP</a>
                <a href="#2d-dp">2D DP</a>
                <a href="#knapsack">Knapsack</a>
                <a href="#lcs">LCS/LIS</a>
                <a href="#strings">Strings</a>
                <a href="#patterns">Patterns</a>
                <a href="#optimization">Optimization</a>
            </div>
        </nav>
        
        <div class="content">
            <!-- BASICS -->
            <div class="section" id="basics">
                <h2>🎯 What is Dynamic Programming?</h2>
                <p><strong>Dynamic Programming (DP)</strong> is an algorithmic technique for solving optimization problems by breaking them down into simpler subproblems and storing the results to avoid redundant calculations.</p>
                
                <div class="highlight-box">
                    <h4>🔑 Core Idea:</h4>
                    <p><em>"Those who cannot remember the past are condemned to repeat it"</em> - In DP, we remember past computations to avoid repeating work!</p>
                    <ul>
                        <li><strong>Solve once, use many times</strong> - Store subproblem solutions</li>
                        <li><strong>Optimal substructure</strong> - Optimal solution contains optimal solutions to subproblems</li>
                        <li><strong>Overlapping subproblems</strong> - Same subproblems solved multiple times</li>
                    </ul>
                </div>
                
                <h3>Simple Example: Fibonacci Numbers</h3>
                <p>Without DP, computing Fibonacci numbers has exponential time complexity due to repeated calculations.</p>
                
                <div class="visual-example">
                    <h4>Recursive Tree for fib(5):</h4>
<pre style="font-family: monospace; line-height: 1.8;">
                    fib(5)
                   /      \
              fib(4)      fib(3)
              /    \      /    \
         fib(3) fib(2) fib(2) fib(1)
         /   \   /  \   /  \
    fib(2) fib(1) ...
    
<strong style="color: #e74c3c;">Notice: fib(3) calculated 2 times, fib(2) calculated 3 times!</strong>
</pre>
                </div>
                
<div class="code-block"><span class="comment"># BAD: Naive Recursion - O(2^n) time</span>
<span class="keyword">def</span> <span class="function">fib_recursive</span>(n):
    <span class="keyword">if</span> n <= 1:
        <span class="keyword">return</span> n
    <span class="keyword">return</span> fib_recursive(n-1) + fib_recursive(n-2)

<span class="comment"># GOOD: Top-Down DP with Memoization - O(n) time</span>
<span class="keyword">def</span> <span class="function">fib_memo</span>(n, memo={}):
    <span class="keyword">if</span> n <span class="keyword">in</span> memo:
        <span class="keyword">return</span> memo[n]
    <span class="keyword">if</span> n <= 1:
        <span class="keyword">return</span> n
    
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    <span class="keyword">return</span> memo[n]

<span class="comment"># BETTER: Bottom-Up DP with Tabulation - O(n) time, O(n) space</span>
<span class="keyword">def</span> <span class="function">fib_dp</span>(n):
    <span class="keyword">if</span> n <= 1:
        <span class="keyword">return</span> n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    <span class="keyword">return</span> dp[n]

<span class="comment"># BEST: Space-Optimized - O(n) time, O(1) space</span>
<span class="keyword">def</span> <span class="function">fib_optimized</span>(n):
    <span class="keyword">if</span> n <= 1:
        <span class="keyword">return</span> n
    
    prev2, prev1 = 0, 1
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(2, n + 1):
        curr = prev1 + prev2
        prev2, prev1 = prev1, curr
    
    <span class="keyword">return</span> prev1</div>

                <div class="comparison-grid">
                    <div class="card">
                        <h3>Recursion</h3>
                        <p><strong>Time:</strong> O(2ⁿ)</p>
                        <p><strong>Space:</strong> O(n)</p>
                        <p>❌ Exponential - Very slow!</p>
                    </div>
                    <div class="card">
                        <h3>Memoization</h3>
                        <p><strong>Time:</strong> O(n)</p>
                        <p><strong>Space:</strong> O(n)</p>
                        <p>✅ Fast with caching</p>
                    </div>
                    <div class="card">
                        <h3>Tabulation</h3>
                        <p><strong>Time:</strong> O(n)</p>
                        <p><strong>Space:</strong> O(n)</p>
                        <p>✅ Iterative, predictable</p>
                    </div>
                    <div class="card">
                        <h3>Space-Optimized</h3>
                        <p><strong>Time:</strong> O(n)</p>
                        <p><strong>Space:</strong> O(1)</p>
                        <p>🌟 Best solution!</p>
                    </div>
                </div>
            </div>
            
            <!-- CHARACTERISTICS -->
            <div class="section" id="characteristics">
                <h2>📚 When to Use Dynamic Programming?</h2>
                <p>DP is applicable when a problem has these two key characteristics:</p>
                
                <div class="comparison-grid">
                    <div class="card">
                        <h3>1. Optimal Substructure</h3>
                        <p>Optimal solution can be constructed from optimal solutions of subproblems</p>
                        <h4 style="margin-top: 15px;">Example:</h4>
                        <p>Shortest path from A to C through B = Shortest(A→B) + Shortest(B→C)</p>
                    </div>
                    <div class="card">
                        <h3>2. Overlapping Subproblems</h3>
                        <p>Same subproblems are solved multiple times</p>
                        <h4 style="margin-top: 15px;">Example:</h4>
                        <p>Fibonacci: fib(5) needs fib(3), fib(4) also needs fib(3)</p>
                    </div>
                </div>
                
                <h3>DP vs Divide & Conquer vs Greedy</h3>
                <table>
                    <tr>
                        <th>Aspect</th>
                        <th>Dynamic Programming</th>
                        <th>Divide & Conquer</th>
                        <th>Greedy</th>
                    </tr>
                    <tr>
                        <td><strong>Subproblems</strong></td>
                        <td>Overlapping</td>
                        <td>Independent</td>
                        <td>No subproblems</td>
                    </tr>
                    <tr>
                        <td><strong>Approach</strong></td>
                        <td>Try all possibilities, store results</td>
                        <td>Split, solve, combine</td>
                        <td>Make locally optimal choice</td>
                    </tr>
                    <tr>
                        <td><strong>Solution</strong></td>
                        <td>Always optimal</td>
                        <td>Always optimal</td>
                        <td>May not be optimal</td>
                    </tr>
                    <tr>
                        <td><strong>Examples</strong></td>
                        <td>Fibonacci, Knapsack, LCS</td>
                        <td>Merge Sort, Binary Search</td>
                        <td>Dijkstra, Huffman Coding</td>
                    </tr>
                    <tr>
                        <td><strong>Time</strong></td>
                        <td>Polynomial (usually)</td>
                        <td>Often O(n log n)</td>
                        <td>Usually linear/log</td>
                    </tr>
                </table>
                
                <div class="info-box">
                    <h4>🎯 How to Identify DP Problems?</h4>
                    <ul>
                        <li>Problem asks for <strong>optimization</strong> (max/min)</li>
                        <li>Problem asks to <strong>count</strong> total ways</li>
                        <li>Problem has <strong>choices</strong> at each step</li>
                        <li>Current decision depends on <strong>previous decisions</strong></li>
                        <li>Keywords: "maximum", "minimum", "longest", "shortest", "count ways", "possible"</li>
                    </ul>
                </div>
                
                <h3>Classic DP Problem Categories</h3>
                <div class="comparison-grid">
                    <div class="card">
                        <h3>Optimization</h3>
                        <p>Find maximum or minimum value</p>
                        <p><em>Examples: Knapsack, Coin Change, Maximum Subarray</em></p>
                    </div>
                    <div class="card">
                        <h3>Combinatorics</h3>
                        <p>Count number of ways</p>
                        <p><em>Examples: Climbing Stairs, Unique Paths, Coin Change II</em></p>
                    </div>
                    <div class="card">
                        <h3>Sequences</h3>
                        <p>Find optimal subsequence/substring</p>
                        <p><em>Examples: LCS, LIS, Edit Distance</em></p>
                    </div>
                    <div class="card">
                        <h3>Game Theory</h3>
                        <p>Optimal strategy in games</p>
                        <p><em>Examples: Nim Game, Stone Game, Predict Winner</em></p>
                    </div>
                </div>
            </div>
            
            <!-- APPROACHES -->
            <div class="section" id="approaches">
                <h2>🔄 Two Main DP Approaches</h2>
                
                <h3>1. Top-Down (Memoization)</h3>
                <p>Start with original problem, recursively break down, store results</p>
                
                <div class="algorithm-box">
                    <h4>✅ Top-Down Characteristics:</h4>
                    <ul>
                        <li><strong>Recursive</strong> - Natural problem decomposition</li>
                        <li><strong>Memoization</strong> - Cache results in hash map/array</li>
                        <li><strong>Lazy</strong> - Only compute needed subproblems</li>
                        <li><strong>Intuitive</strong> - Easier to think about</li>
                    </ul>
                    <h4 style="margin-top: 15px;">❌ Drawbacks:</h4>
                    <ul>
                        <li>Stack overflow risk for deep recursion</li>
                        <li>Extra overhead from function calls</li>
                    </ul>
                </div>
                
<div class="code-block"><span class="comment"># Top-Down Template</span>
<span class="keyword">def</span> <span class="function">top_down</span>(problem_params):
    memo = {}
    
    <span class="keyword">def</span> <span class="function">helper</span>(state):
        <span class="comment"># Base case</span>
        <span class="keyword">if</span> base_condition:
            <span class="keyword">return</span> base_value
        
        <span class="comment"># Check if already computed</span>
        <span class="keyword">if</span> state <span class="keyword">in</span> memo:
            <span class="keyword">return</span> memo[state]
        
        <span class="comment"># Compute result from subproblems</span>
        result = compute_from_subproblems(state)
        
        <span class="comment"># Store and return</span>
        memo[state] = result
        <span class="keyword">return</span> result
    
    <span class="keyword">return</span> helper(initial_state)</div>

                <h3>2. Bottom-Up (Tabulation)</h3>
                <p>Start from base cases, build up to final solution iteratively</p>
                
                <div class="algorithm-box">
                    <h4>✅ Bottom-Up Characteristics:</h4>
                    <ul>
                        <li><strong>Iterative</strong> - Uses loops, no recursion</li>
                        <li><strong>Tabulation</strong> - Fill DP table systematically</li>
                        <li><strong>Eager</strong> - Compute all subproblems</li>
                        <li><strong>Efficient</strong> - Better space optimization possible</li>
                    </ul>
                    <h4 style="margin-top: 15px;">❌ Drawbacks:</h4>
                    <ul>
                        <li>Need to determine exact order of computation</li>
                        <li>May compute unnecessary subproblems</li>
                    </ul>
                </div>
                
<div class="code-block"><span class="comment"># Bottom-Up Template</span>
<span class="keyword">def</span> <span class="function">bottom_up</span>(problem_params):
    <span class="comment"># Initialize DP table</span>
    dp = initialize_table()
    
    <span class="comment"># Set base cases</span>
    dp[base_indices] = base_values
    
    <span class="comment"># Fill table in correct order</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(...):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(...):
            dp[i][j] = compute_from_previous(dp, i, j)
    
    <span class="keyword">return</span> dp[final_state]</div>

                <h3>Comparison Example: Climbing Stairs</h3>
                <p>You can climb 1 or 2 steps. How many ways to reach step n?</p>
                
<div class="code-block"><span class="comment"># Top-Down with Memoization</span>
<span class="keyword">def</span> <span class="function">climb_stairs_memo</span>(n, memo={}):
    <span class="keyword">if</span> n <= 2:
        <span class="keyword">return</span> n
    <span class="keyword">if</span> n <span class="keyword">in</span> memo:
        <span class="keyword">return</span> memo[n]
    
    memo[n] = climb_stairs_memo(n-1, memo) + climb_stairs_memo(n-2, memo)
    <span class="keyword">return</span> memo[n]

<span class="comment"># Bottom-Up with Tabulation</span>
<span class="keyword">def</span> <span class="function">climb_stairs_dp</span>(n):
    <span class="keyword">if</span> n <= 2:
        <span class="keyword">return</span> n
    
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    <span class="keyword">return</span> dp[n]

<span class="comment"># Space-Optimized (Only need last 2 values)</span>
<span class="keyword">def</span> <span class="function">climb_stairs_optimized</span>(n):
    <span class="keyword">if</span> n <= 2:
        <span class="keyword">return</span> n
    
    prev2, prev1 = 1, 2
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(3, n + 1):
        curr = prev1 + prev2
        prev2, prev1 = prev1, curr
    
    <span class="keyword">return</span> prev1</div>
            </div>
            
            <!-- 1D DP -->
            <div class="section" id="1d-dp">
                <h2>📏 1D Dynamic Programming</h2>
                <p>Problems where state can be represented with a single variable</p>
                
                <h3>Problem 1: House Robber</h3>
                <p>Rob houses in a line, can't rob adjacent houses. Maximize stolen amount.</p>
                
                <div class="visual-example">
                    <h4>Example: houses = [2, 7, 9, 3, 1]</h4>
<pre>
Houses:    [2]  [7]  [9]  [3]  [1]
            ↓    ↓    ↓    ↓    ↓
DP table:   2    7   11   11   12

Explanation:
dp[0] = 2                    (rob house 0)
dp[1] = max(2, 7) = 7        (rob house 1, skip 0)
dp[2] = max(7, 2+9) = 11     (rob house 0 and 2)
dp[3] = max(11, 7+3) = 11    (keep previous max)
dp[4] = max(11, 11+1) = 12   (rob houses 0, 2, 4)
</pre>
                </div>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">rob</span>(nums):
    <span class="comment">"""
    House Robber - O(n) time, O(n) space
    dp[i] = max money robbing houses 0 to i
    """</span>
    <span class="keyword">if not</span> nums:
        <span class="keyword">return</span> 0
    <span class="keyword">if</span> len(nums) == 1:
        <span class="keyword">return</span> nums[0]
    
    n = len(nums)
    dp = [0] * n
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(2, n):
        <span class="comment"># Either rob current + previous non-adjacent, or skip current</span>
        dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    
    <span class="keyword">return</span> dp[n-1]

<span class="comment"># Space-Optimized: O(n) time, O(1) space</span>
<span class="keyword">def</span> <span class="function">rob_optimized</span>(nums):
    <span class="keyword">if not</span> nums:
        <span class="keyword">return</span> 0
    
    prev2, prev1 = 0, 0
    
    <span class="keyword">for</span> num <span class="keyword">in</span> nums:
        curr = max(prev1, prev2 + num)
        prev2, prev1 = prev1, curr
    
    <span class="keyword">return</span> prev1</div>

                <h3>Problem 2: Coin Change</h3>
                <p>Given coins, find minimum number of coins needed to make amount</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">coin_change</span>(coins, amount):
    <span class="comment">"""
    Coin Change (Minimum Coins)
    Time: O(amount * len(coins)), Space: O(amount)
    dp[i] = minimum coins to make amount i
    """</span>
    dp = [float(<span class="string">'inf'</span>)] * (amount + 1)
    dp[0] = 0  <span class="comment"># 0 coins needed for amount 0</span>
    
    <span class="keyword">for</span> amt <span class="keyword">in</span> range(1, amount + 1):
        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:
            <span class="keyword">if</span> coin <= amt:
                dp[amt] = min(dp[amt], dp[amt - coin] + 1)
    
    <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != float(<span class="string">'inf'</span>) <span class="keyword">else</span> -1

<span class="comment"># Example</span>
print(coin_change([1, 2, 5], 11))  <span class="comment"># Output: 3 (5+5+1)</span></div>

                <h3>Problem 3: Maximum Subarray (Kadane's Algorithm)</h3>
                <p>Find contiguous subarray with maximum sum</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">max_subarray</span>(nums):
    <span class="comment">"""
    Maximum Subarray Sum - Kadane's Algorithm
    Time: O(n), Space: O(1)
    """</span>
    max_sum = nums[0]
    current_sum = nums[0]
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, len(nums)):
        <span class="comment"># Either extend current subarray or start new one</span>
        current_sum = max(nums[i], current_sum + nums[i])
        max_sum = max(max_sum, current_sum)
    
    <span class="keyword">return</span> max_sum

<span class="comment"># Example: [-2,1,-3,4,-1,2,1,-5,4]</span>
<span class="comment"># Output: 6 (subarray [4,-1,2,1])</span></div>

                <h3>Problem 4: Decode Ways</h3>
                <p>Count ways to decode a digit string (A=1, B=2, ..., Z=26)</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">num_decodings</span>(s):
    <span class="comment">"""
    Decode Ways - Count number of ways to decode string
    Time: O(n), Space: O(n)
    dp[i] = number of ways to decode string[0:i]
    """</span>
    <span class="keyword">if not</span> s <span class="keyword">or</span> s[0] == <span class="string">'0'</span>:
        <span class="keyword">return</span> 0
    
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1  <span class="comment"># Empty string</span>
    dp[1] = 1  <span class="comment"># First character (already checked not '0')</span>
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(2, n + 1):
        <span class="comment"># Single digit decode (if not '0')</span>
        <span class="keyword">if</span> s[i-1] != <span class="string">'0'</span>:
            dp[i] += dp[i-1]
        
        <span class="comment"># Two digit decode (if between 10-26)</span>
        two_digit = int(s[i-2:i])
        <span class="keyword">if</span> 10 <= two_digit <= 26:
            dp[i] += dp[i-2]
    
    <span class="keyword">return</span> dp[n]

<span class="comment"># Example: "226" → 3 ways (2-2-6, 22-6, 2-26)</span></div>

                <div class="info-box">
                    <h4>🎯 1D DP Problem Pattern:</h4>
                    <ul>
                        <li><strong>State:</strong> Usually dp[i] = optimal solution for first i elements</li>
                        <li><strong>Transition:</strong> dp[i] depends on dp[i-1], dp[i-2], etc.</li>
                        <li><strong>Base case:</strong> dp[0] or dp[1] initialized</li>
                        <li><strong>Space optimization:</strong> Often only need last few values</li>
                    </ul>
                </div>
            </div>
            
            <!-- 2D DP -->
            <div class="section" id="2d-dp">
                <h2>📐 2D Dynamic Programming</h2>
                <p>Problems where state requires two variables (grid, two sequences, etc.)</p>
                
                <h3>Problem 1: Unique Paths</h3>
                <p>Count paths from top-left to bottom-right in grid (only move right/down)</p>
                
                <div class="visual-example">
                    <h4>3x7 Grid DP Table:</h4>
                    <div class="dp-table">
                        <table>
                            <tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
                            <tr><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr>
                            <tr><td>1</td><td>3</td><td>6</td><td>10</td><td>15</td><td>21</td><td class="highlight">28</td></tr>
                        </table>
                    </div>
                    <p><em>dp[i][j] = dp[i-1][j] + dp[i][j-1] (paths from top + paths from left)</em></p>
                </div>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">unique_paths</span>(m, n):
    <span class="comment">"""
    Unique Paths in Grid
    Time: O(m*n), Space: O(m*n)
    """</span>
    dp = [[0] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]
    
    <span class="comment"># Initialize first row and column (only 1 way each)</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):
        dp[i][0] = 1
    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):
        dp[0][j] = 1
    
    <span class="comment"># Fill remaining cells</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, m):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    
    <span class="keyword">return</span> dp[m-1][n-1]

<span class="comment"># Space-Optimized: O(m*n) time, O(n) space</span>
<span class="keyword">def</span> <span class="function">unique_paths_optimized</span>(m, n):
    dp = [1] * n  <span class="comment"># Only need one row</span>
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, m):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(1, n):
            dp[j] += dp[j-1]  <span class="comment"># Add paths from left</span>
    
    <span class="keyword">return</span> dp[n-1]</div>

                <h3>Problem 2: Minimum Path Sum</h3>
                <p>Find path with minimum sum from top-left to bottom-right</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">min_path_sum</span>(grid):
    <span class="comment">"""
    Minimum Path Sum in Grid
    Time: O(m*n), Space: O(1) - modify grid in-place
    """</span>
    m, n = len(grid), len(grid[0])
    
    <span class="comment"># Initialize first row (can only come from left)</span>
    <span class="keyword">for</span> j <span class="keyword">in</span> range(1, n):
        grid[0][j] += grid[0][j-1]
    
    <span class="comment"># Initialize first column (can only come from top)</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, m):
        grid[i][0] += grid[i-1][0]
    
    <span class="comment"># Fill remaining cells (min of top or left + current)</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, m):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(1, n):
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
    
    <span class="keyword">return</span> grid[m-1][n-1]</div>

                <h3>Problem 3: Longest Common Subsequence (LCS)</h3>
                <p>Find length of longest subsequence common to both strings</p>
                
                <div class="visual-example">
                    <h4>LCS("ABCDGH", "AEDFHR") = 3 (ADH)</h4>
                    <div class="dp-table">
                        <table>
                            <tr><th></th><th></th><th>A</th><th>E</th><th>D</th><th>F</th><th>H</th><th>R</th></tr>
                            <tr><th></th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                            <tr><th>A</th><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
                            <tr><th>B</th><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
                            <tr><th>C</th><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
                            <tr><th>D</th><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td></tr>
                            <tr><th>G</th><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td></tr>
                            <tr><th>H</th><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td class="highlight">3</td><td>3</td></tr>
                        </table>
                    </div>
                </div>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">longest_common_subsequence</span>(text1, text2):
    <span class="comment">"""
    Longest Common Subsequence
    Time: O(m*n), Space: O(m*n)
    dp[i][j] = LCS length of text1[0:i] and text2[0:j]
    """</span>
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + 1)]
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, m + 1):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(1, n + 1):
            <span class="keyword">if</span> text1[i-1] == text2[j-1]:
                <span class="comment"># Characters match: add 1 to diagonal</span>
                dp[i][j] = dp[i-1][j-1] + 1
            <span class="keyword">else</span>:
                <span class="comment"># Take max from top or left</span>
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    <span class="keyword">return</span> dp[m][n]

<span class="comment"># Space-Optimized: O(m*n) time, O(n) space</span>
<span class="keyword">def</span> <span class="function">lcs_optimized</span>(text1, text2):
    m, n = len(text1), len(text2)
    prev = [0] * (n + 1)
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, m + 1):
        curr = [0] * (n + 1)
        <span class="keyword">for</span> j <span class="keyword">in</span> range(1, n + 1):
            <span class="keyword">if</span> text1[i-1] == text2[j-1]:
                curr[j] = prev[j-1] + 1
            <span class="keyword">else</span>:
                curr[j] = max(prev[j], curr[j-1])
        prev = curr
    
    <span class="keyword">return</span> prev[n]</div>

                <h3>Problem 4: Edit Distance (Levenshtein Distance)</h3>
                <p>Minimum operations (insert, delete, replace) to convert string1 to string2</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">edit_distance</span>(word1, word2):
    <span class="comment">"""
    Edit Distance / Levenshtein Distance
    Time: O(m*n), Space: O(m*n)
    dp[i][j] = min operations to convert word1[0:i] to word2[0:j]
    """</span>
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + 1)]
    
    <span class="comment"># Initialize: convert empty string to word2 (all inserts)</span>
    <span class="keyword">for</span> j <span class="keyword">in</span> range(n + 1):
        dp[0][j] = j
    
    <span class="comment"># Initialize: convert word1 to empty string (all deletes)</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(m + 1):
        dp[i][0] = i
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, m + 1):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(1, n + 1):
            <span class="keyword">if</span> word1[i-1] == word2[j-1]:
                <span class="comment"># Characters match: no operation needed</span>
                dp[i][j] = dp[i-1][j-1]
            <span class="keyword">else</span>:
                <span class="comment"># Min of: insert, delete, replace</span>
                dp[i][j] = min(
                    dp[i][j-1] + 1,    <span class="comment"># Insert</span>
                    dp[i-1][j] + 1,    <span class="comment"># Delete</span>
                    dp[i-1][j-1] + 1   <span class="comment"># Replace</span>
                )
    
    <span class="keyword">return</span> dp[m][n]

<span class="comment"># Example: edit_distance("horse", "ros") = 3</span>
<span class="comment"># horse → rorse (replace h with r)</span>
<span class="comment"># rorse → rose (remove r)</span>
<span class="comment"># rose → ros (remove e)</span></div>
            </div>
            
            <!-- KNAPSACK -->
            <div class="section" id="knapsack">
                <h2>🎒 Knapsack Problems</h2>
                <p>Classic optimization problems involving selecting items with constraints</p>
                
                <h3>1. 0/1 Knapsack</h3>
                <p>Each item can be taken at most once. Maximize value within weight capacity.</p>
                
                <div class="visual-example">
                    <h4>Example: weights=[1,3,4,5], values=[1,4,5,7], capacity=7</h4>
                    <div class="dp-table">
                        <table>
                            <tr><th>Item\Cap</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr>
                            <tr><th>0</th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                            <tr><th>1 (w=1,v=1)</th><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
                            <tr><th>2 (w=3,v=4)</th><td>0</td><td>1</td><td>1</td><td>4</td><td>5</td><td>5</td><td>5</td><td>5</td></tr>
                            <tr><th>3 (w=4,v=5)</th><td>0</td><td>1</td><td>1</td><td>4</td><td>5</td><td>6</td><td>6</td><td>9</td></tr>
                            <tr><th>4 (w=5,v=7)</th><td>0</td><td>1</td><td>1</td><td>4</td><td>5</td><td>7</td><td>8</td><td class="highlight">9</td></tr>
                        </table>
                    </div>
                    <p><em>Optimal: Take items 2 and 3 (weights 3+4=7, values 4+5=9)</em></p>
                </div>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">knapsack_01</span>(weights, values, capacity):
    <span class="comment">"""
    0/1 Knapsack Problem
    Time: O(n * capacity), Space: O(n * capacity)
    dp[i][w] = max value using first i items with weight limit w
    """</span>
    n = len(weights)
    dp = [[0] * (capacity + 1) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + 1)]
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, n + 1):
        <span class="keyword">for</span> w <span class="keyword">in</span> range(capacity + 1):
            <span class="keyword">if</span> weights[i-1] <= w:
                <span class="comment"># Max of: don't take item OR take item</span>
                dp[i][w] = max(
                    dp[i-1][w],                              <span class="comment"># Don't take</span>
                    dp[i-1][w - weights[i-1]] + values[i-1]  <span class="comment"># Take</span>
                )
            <span class="keyword">else</span>:
                <span class="comment"># Can't take item (too heavy)</span>
                dp[i][w] = dp[i-1][w]
    
    <span class="keyword">return</span> dp[n][capacity]

<span class="comment"># Space-Optimized: O(n * capacity) time, O(capacity) space</span>
<span class="keyword">def</span> <span class="function">knapsack_01_optimized</span>(weights, values, capacity):
    dp = [0] * (capacity + 1)
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(weights)):
        <span class="comment"># Traverse backwards to avoid using updated values</span>
        <span class="keyword">for</span> w <span class="keyword">in</span> range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    <span class="keyword">return</span> dp[capacity]</div>

                <h3>2. Unbounded Knapsack</h3>
                <p>Each item can be taken unlimited times</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">unbounded_knapsack</span>(weights, values, capacity):
    <span class="comment">"""
    Unbounded Knapsack - Unlimited items
    Time: O(n * capacity), Space: O(capacity)
    """</span>
    dp = [0] * (capacity + 1)
    
    <span class="keyword">for</span> w <span class="keyword">in</span> range(capacity + 1):
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(weights)):
            <span class="keyword">if</span> weights[i] <= w:
                dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    <span class="keyword">return</span> dp[capacity]</div>

                <h3>3. Subset Sum Problem</h3>
                <p>Check if subset exists with sum equal to target</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">subset_sum</span>(nums, target):
    <span class="comment">"""
    Subset Sum - Can we make target sum?
    Time: O(n * target), Space: O(target)
    """</span>
    dp = [<span class="keyword">False</span>] * (target + 1)
    dp[0] = <span class="keyword">True</span>  <span class="comment"># Empty subset sums to 0</span>
    
    <span class="keyword">for</span> num <span class="keyword">in</span> nums:
        <span class="comment"># Traverse backwards to avoid reusing same element</span>
        <span class="keyword">for</span> t <span class="keyword">in</span> range(target, num - 1, -1):
            dp[t] = dp[t] <span class="keyword">or</span> dp[t - num]
    
    <span class="keyword">return</span> dp[target]

<span class="comment"># Example: subset_sum([3, 34, 4, 12, 5, 2], 9) = True (4+5)</span></div>

                <h3>4. Partition Equal Subset Sum</h3>
                <p>Can we partition array into two subsets with equal sum?</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">can_partition</span>(nums):
    <span class="comment">"""
    Partition Equal Subset Sum
    Reduce to subset sum with target = total_sum / 2
    """</span>
    total = sum(nums)
    
    <span class="comment"># If odd sum, can't partition equally</span>
    <span class="keyword">if</span> total % 2 != 0:
        <span class="keyword">return False</span>
    
    target = total // 2
    dp = [<span class="keyword">False</span>] * (target + 1)
    dp[0] = <span class="keyword">True</span>
    
    <span class="keyword">for</span> num <span class="keyword">in</span> nums:
        <span class="keyword">for</span> t <span class="keyword">in</span> range(target, num - 1, -1):
            dp[t] = dp[t] <span class="keyword">or</span> dp[t - num]
    
    <span class="keyword">return</span> dp[target]

<span class="comment"># Example: can_partition([1, 5, 11, 5]) = True ([1,5,5] and [11])</span></div>

                <div class="warning-box">
                    <h4>⚠️ Knapsack Space Optimization Trick:</h4>
                    <p>When optimizing 2D DP to 1D:</p>
                    <ul>
                        <li><strong>0/1 Knapsack:</strong> Traverse capacity backwards (right to left)</li>
                        <li><strong>Unbounded Knapsack:</strong> Traverse capacity forwards (left to right)</li>
                        <li><strong>Reason:</strong> Backwards prevents using same item multiple times in 0/1</li>
                    </ul>
                </div>
            </div>
            
            <!-- LCS/LIS -->
            <div class="section" id="lcs">
                <h2>📊 Longest Common/Increasing Subsequence</h2>
                
                <h3>1. Longest Increasing Subsequence (LIS)</h3>
                <p>Find length of longest strictly increasing subsequence</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">length_of_lis</span>(nums):
    <span class="comment">"""
    Longest Increasing Subsequence - O(n²) DP solution
    dp[i] = length of LIS ending at index i
    """</span>
    <span class="keyword">if not</span> nums:
        <span class="keyword">return</span> 0
    
    n = len(nums)
    dp = [1] * n  <span class="comment"># Each element is LIS of length 1</span>
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, n):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):
            <span class="keyword">if</span> nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    <span class="keyword">return</span> max(dp)

<span class="comment"># Optimal: O(n log n) using Binary Search + Patience Sorting</span>
<span class="keyword">def</span> <span class="function">length_of_lis_optimal</span>(nums):
    <span class="keyword">import</span> bisect
    
    <span class="comment"># tails[i] = smallest tail of LIS of length i+1</span>
    tails = []
    
    <span class="keyword">for</span> num <span class="keyword">in</span> nums:
        pos = bisect.bisect_left(tails, num)
        <span class="keyword">if</span> pos == len(tails):
            tails.append(num)
        <span class="keyword">else</span>:
            tails[pos] = num
    
    <span class="keyword">return</span> len(tails)

<span class="comment"># Example: [10,9,2,5,3,7,101,18] → 4 ([2,3,7,101])</span></div>

                <h3>2. Longest Common Substring</h3>
                <p>Find longest contiguous substring common to both strings</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">longest_common_substring</span>(text1, text2):
    <span class="comment">"""
    Longest Common Substring (contiguous)
    Time: O(m*n), Space: O(m*n)
    dp[i][j] = length of common substring ending at i, j
    """</span>
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + 1)]
    max_len = 0
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, m + 1):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(1, n + 1):
            <span class="keyword">if</span> text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
                max_len = max(max_len, dp[i][j])
            <span class="keyword">else</span>:
                dp[i][j] = 0  <span class="comment"># Reset if characters don't match</span>
    
    <span class="keyword">return</span> max_len</div>

                <h3>3. Palindromic Subsequences</h3>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">longest_palindromic_subsequence</span>(s):
    <span class="comment">"""
    Longest Palindromic Subsequence
    Time: O(n²), Space: O(n²)
    dp[i][j] = LPS length in s[i:j+1]
    """</span>
    n = len(s)
    dp = [[0] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]
    
    <span class="comment"># Base case: single character</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
        dp[i][i] = 1
    
    <span class="comment"># Fill table for increasing lengths</span>
    <span class="keyword">for</span> length <span class="keyword">in</span> range(2, n + 1):
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - length + 1):
            j = i + length - 1
            
            <span class="keyword">if</span> s[i] == s[j]:
                <span class="comment"># Characters match: add 2 to inner palindrome</span>
                dp[i][j] = dp[i+1][j-1] + 2
            <span class="keyword">else</span>:
                <span class="comment"># Take max of excluding either endpoint</span>
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    
    <span class="keyword">return</span> dp[0][n-1]

<span class="keyword">def</span> <span class="function">longest_palindromic_substring</span>(s):
    <span class="comment">"""
    Longest Palindromic Substring (contiguous)
    Time: O(n²), Space: O(1) - expand around center
    """</span>
    <span class="keyword">def</span> <span class="function">expand_around_center</span>(left, right):
        <span class="keyword">while</span> left >= 0 <span class="keyword">and</span> right < len(s) <span class="keyword">and</span> s[left] == s[right]:
            left -= 1
            right += 1
        <span class="keyword">return</span> right - left - 1
    
    start, max_len = 0, 0
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):
        <span class="comment"># Odd length palindromes (center is single char)</span>
        len1 = expand_around_center(i, i)
        <span class="comment"># Even length palindromes (center is between chars)</span>
        len2 = expand_around_center(i, i + 1)
        
        curr_len = max(len1, len2)
        <span class="keyword">if</span> curr_len > max_len:
            max_len = curr_len
            start = i - (curr_len - 1) // 2
    
    <span class="keyword">return</span> s[start:start + max_len]</div>
            </div>
            
            <!-- STRING DP -->
            <div class="section" id="strings">
                <h2>🔤 String Dynamic Programming</h2>
                
                <h3>1. Word Break</h3>
                <p>Check if string can be segmented into dictionary words</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">word_break</span>(s, wordDict):
    <span class="comment">"""
    Word Break - Can string be segmented?
    Time: O(n² * m) where m = avg word length
    Space: O(n)
    dp[i] = True if s[0:i] can be segmented
    """</span>
    n = len(s)
    dp = [<span class="keyword">False</span>] * (n + 1)
    dp[0] = <span class="keyword">True</span>  <span class="comment"># Empty string</span>
    
    word_set = set(wordDict)
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, n + 1):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):
            <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> word_set:
                dp[i] = <span class="keyword">True</span>
                <span class="keyword">break</span>
    
    <span class="keyword">return</span> dp[n]

<span class="comment"># Example: word_break("leetcode", ["leet","code"]) = True</span>

<span class="keyword">def</span> <span class="function">word_break_ii</span>(s, wordDict):
    <span class="comment">"""
    Word Break II - Return all possible sentences
    """</span>
    word_set = set(wordDict)
    memo = {}
    
    <span class="keyword">def</span> <span class="function">backtrack</span>(start):
        <span class="keyword">if</span> start == len(s):
            <span class="keyword">return</span> [[]]
        <span class="keyword">if</span> start <span class="keyword">in</span> memo:
            <span class="keyword">return</span> memo[start]
        
        result = []
        <span class="keyword">for</span> end <span class="keyword">in</span> range(start + 1, len(s) + 1):
            word = s[start:end]
            <span class="keyword">if</span> word <span class="keyword">in</span> word_set:
                <span class="keyword">for</span> rest <span class="keyword">in</span> backtrack(end):
                    result.append([word] + rest)
        
        memo[start] = result
        <span class="keyword">return</span> result
    
    <span class="keyword">return</span> [<span class="string">' '</span>.join(words) <span class="keyword">for</span> words <span class="keyword">in</span> backtrack(0)]</div>

                <h3>2. Regular Expression Matching</h3>
                <p>Match string with pattern containing '.' and '*'</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">is_match</span>(s, p):
    <span class="comment">"""
    Regular Expression Matching
    '.' matches any single character
    '*' matches zero or more of preceding element
    Time: O(m*n), Space: O(m*n)
    """</span>
    m, n = len(s), len(p)
    dp = [[<span class="keyword">False</span>] * (n + 1) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + 1)]
    
    <span class="comment"># Empty string matches empty pattern</span>
    dp[0][0] = <span class="keyword">True</span>
    
    <span class="comment"># Handle patterns like a*, a*b*, a*b*c*</span>
    <span class="keyword">for</span> j <span class="keyword">in</span> range(2, n + 1):
        <span class="keyword">if</span> p[j-1] == <span class="string">'*'</span>:
            dp[0][j] = dp[0][j-2]
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, m + 1):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(1, n + 1):
            <span class="keyword">if</span> p[j-1] == <span class="string">'*'</span>:
                <span class="comment"># Two choices: use * zero times OR one+ times</span>
                dp[i][j] = dp[i][j-2]  <span class="comment"># Zero times</span>
                <span class="keyword">if</span> p[j-2] == s[i-1] <span class="keyword">or</span> p[j-2] == <span class="string">'.'</span>:
                    dp[i][j] = dp[i][j] <span class="keyword">or</span> dp[i-1][j]  <span class="comment"># One+ times</span>
            <span class="keyword">elif</span> p[j-1] == <span class="string">'.'</span> <span class="keyword">or</span> p[j-1] == s[i-1]:
                <span class="comment"># Characters match or wildcard</span>
                dp[i][j] = dp[i-1][j-1]
    
    <span class="keyword">return</span> dp[m][n]</div>

                <h3>3. Wildcard Matching</h3>
                <p>Match string with pattern containing '?' and '*'</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">wildcard_match</span>(s, p):
    <span class="comment">"""
    Wildcard Matching
    '?' matches any single character
    '*' matches any sequence (including empty)
    Time: O(m*n), Space: O(m*n)
    """</span>
    m, n = len(s), len(p)
    dp = [[<span class="keyword">False</span>] * (n + 1) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + 1)]
    
    dp[0][0] = <span class="keyword">True</span>
    
    <span class="comment"># Handle leading asterisks in pattern</span>
    <span class="keyword">for</span> j <span class="keyword">in</span> range(1, n + 1):
        <span class="keyword">if</span> p[j-1] == <span class="string">'*'</span>:
            dp[0][j] = dp[0][j-1]
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, m + 1):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(1, n + 1):
            <span class="keyword">if</span> p[j-1] == <span class="string">'*'</span>:
                <span class="comment"># Match empty OR match one+ characters</span>
                dp[i][j] = dp[i][j-1] <span class="keyword">or</span> dp[i-1][j]
            <span class="keyword">elif</span> p[j-1] == <span class="string">'?'</span> <span class="keyword">or</span> p[j-1] == s[i-1]:
                dp[i][j] = dp[i-1][j-1]
    
    <span class="keyword">return</span> dp[m][n]</div>

                <h3>4. Distinct Subsequences</h3>
                <p>Count distinct subsequences of s that equals t</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">num_distinct</span>(s, t):
    <span class="comment">"""
    Distinct Subsequences - Count ways
    Time: O(m*n), Space: O(m*n)
    dp[i][j] = number of distinct subsequences of s[0:i] that equals t[0:j]
    """</span>
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + 1)]
    
    <span class="comment"># Empty string is subsequence of any string (1 way)</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(m + 1):
        dp[i][0] = 1
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, m + 1):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(1, n + 1):
            <span class="comment"># Don't use s[i-1]</span>
            dp[i][j] = dp[i-1][j]
            
            <span class="comment"># Use s[i-1] if it matches t[j-1]</span>
            <span class="keyword">if</span> s[i-1] == t[j-1]:
                dp[i][j] += dp[i-1][j-1]
    
    <span class="keyword">return</span> dp[m][n]

<span class="comment"># Example: num_distinct("rabbbit", "rabbit") = 3</span></div>
            </div>
            
            <!-- PATTERNS -->
            <div class="section" id="patterns">
                <h2>🎨 Common DP Patterns</h2>
                
                <h3>Pattern 1: Linear Sequence</h3>
                <div class="algorithm-box">
                    <p><strong>State:</strong> dp[i] = optimal solution for first i elements</p>
                    <p><strong>Transition:</strong> dp[i] depends on dp[i-1], dp[i-2], etc.</p>
                    <p><strong>Examples:</strong> Fibonacci, Climbing Stairs, House Robber</p>
                </div>
                
                <h3>Pattern 2: Two Sequences</h3>
                <div class="algorithm-box">
                    <p><strong>State:</strong> dp[i][j] = solution involving seq1[0:i] and seq2[0:j]</p>
                    <p><strong>Transition:</strong> Consider matching/not matching current elements</p>
                    <p><strong>Examples:</strong> LCS, Edit Distance, Wildcard Matching</p>
                </div>
                
                <h3>Pattern 3: Grid Traversal</h3>
                <div class="algorithm-box">
                    <p><strong>State:</strong> dp[i][j] = solution at position (i, j)</p>
                    <p><strong>Transition:</strong> Come from top, left, or diagonal</p>
                    <p><strong>Examples:</strong> Unique Paths, Min Path Sum, Dungeon Game</p>
                </div>
                
                <h3>Pattern 4: Interval DP</h3>
                <div class="algorithm-box">
                    <p><strong>State:</strong> dp[i][j] = solution for range [i, j]</p>
                    <p><strong>Transition:</strong> Split interval at different points</p>
                    <p><strong>Examples:</strong> Matrix Chain Multiplication, Burst Balloons</p>
                </div>
                
                <h3>Problem: Burst Balloons (Interval DP)</h3>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">max_coins</span>(nums):
    <span class="comment">"""
    Burst Balloons - Maximize coins
    Time: O(n³), Space: O(n²)
    dp[i][j] = max coins bursting balloons in range (i, j)
    """</span>
    <span class="comment"># Add dummy balloons with value 1 at both ends</span>
    nums = [1] + nums + [1]
    n = len(nums)
    dp = [[0] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]
    
    <span class="comment"># Length of interval</span>
    <span class="keyword">for</span> length <span class="keyword">in</span> range(2, n):
        <span class="keyword">for</span> left <span class="keyword">in</span> range(n - length):
            right = left + length
            
            <span class="comment"># Try bursting each balloon k last in range (left, right)</span>
            <span class="keyword">for</span> k <span class="keyword">in</span> range(left + 1, right):
                <span class="comment"># Coins from bursting k last + left and right subproblems</span>
                coins = nums[left] * nums[k] * nums[right]
                coins += dp[left][k] + dp[k][right]
                dp[left][right] = max(dp[left][right], coins)
    
    <span class="keyword">return</span> dp[0][n-1]</div>

                <h3>Pattern 5: State Machine DP</h3>
                <div class="algorithm-box">
                    <p><strong>State:</strong> dp[i][state] = solution at position i in given state</p>
                    <p><strong>Transition:</strong> State transitions based on actions</p>
                    <p><strong>Examples:</strong> Stock Trading, Paint House</p>
                </div>
                
                <h3>Problem: Best Time to Buy/Sell Stock</h3>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">max_profit</span>(prices):
    <span class="comment">"""
    Best Time to Buy/Sell Stock (unlimited transactions)
    Time: O(n), Space: O(1)
    """</span>
    profit = 0
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, len(prices)):
        <span class="keyword">if</span> prices[i] > prices[i-1]:
            profit += prices[i] - prices[i-1]
    <span class="keyword">return</span> profit

<span class="keyword">def</span> <span class="function">max_profit_k_transactions</span>(k, prices):
    <span class="comment">"""
    Best Time to Buy/Sell Stock with at most k transactions
    Time: O(nk), Space: O(k)
    """</span>
    <span class="keyword">if not</span> prices:
        <span class="keyword">return</span> 0
    
    <span class="keyword">if</span> k >= len(prices) // 2:
        <span class="comment"># Unlimited transactions</span>
        <span class="keyword">return</span> max_profit(prices)
    
    <span class="comment"># dp[i][j][0] = max profit at day i, j transactions, 0 stocks</span>
    <span class="comment"># dp[i][j][1] = max profit at day i, j transactions, 1 stock</span>
    buy = [-float(<span class="string">'inf'</span>)] * (k + 1)
    sell = [0] * (k + 1)
    
    <span class="keyword">for</span> price <span class="keyword">in</span> prices:
        <span class="keyword">for</span> j <span class="keyword">in</span> range(k, 0, -1):
            sell[j] = max(sell[j], buy[j] + price)
            buy[j] = max(buy[j], sell[j-1] - price)
    
    <span class="keyword">return</span> sell[k]

<span class="keyword">def</span> <span class="function">max_profit_with_cooldown</span>(prices):
    <span class="comment">"""
    With cooldown: must wait 1 day after selling before buying
    Time: O(n), Space: O(1)
    """</span>
    <span class="keyword">if not</span> prices:
        <span class="keyword">return</span> 0
    
    <span class="comment"># Three states: hold stock, sold (cooldown), no stock</span>
    hold = -prices[0]
    sold = 0
    rest = 0
    
    <span class="keyword">for</span> price <span class="keyword">in</span> prices[1:]:
        prev_hold = hold
        prev_sold = sold
        
        hold = max(hold, rest - price)  <span class="comment"># Keep or buy</span>
        sold = prev_hold + price        <span class="comment"># Sell</span>
        rest = max(rest, prev_sold)     <span class="comment"># Cooldown</span>
    
    <span class="keyword">return</span> max(sold, rest)</div>

                <h3>Pattern 6: Bitmask DP</h3>
                <div class="algorithm-box">
                    <p><strong>State:</strong> dp[mask] where mask represents subset of elements</p>
                    <p><strong>Transition:</strong> Add/remove elements from subset</p>
                    <p><strong>Examples:</strong> TSP, Assignment Problem, Subset Selection</p>
                </div>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">min_cost_assignment</span>(cost):
    <span class="comment">"""
    Assignment Problem using Bitmask DP
    Assign n workers to n jobs, minimize cost
    Time: O(n² * 2ⁿ), Space: O(2ⁿ)
    """</span>
    n = len(cost)
    dp = [float(<span class="string">'inf'</span>)] * (1 << n)
    dp[0] = 0
    
    <span class="keyword">for</span> mask <span class="keyword">in</span> range(1 << n):
        <span class="keyword">if</span> dp[mask] == float(<span class="string">'inf'</span>):
            <span class="keyword">continue</span>
        
        worker = bin(mask).count(<span class="string">'1'</span>)  <span class="comment"># Number of assigned workers</span>
        
        <span class="keyword">for</span> job <span class="keyword">in</span> range(n):
            <span class="keyword">if</span> mask & (1 << job) == 0:  <span class="comment"># Job not assigned</span>
                new_mask = mask | (1 << job)
                dp[new_mask] = min(dp[new_mask], dp[mask] + cost[worker][job])
    
    <span class="keyword">return</span> dp[(1 << n) - 1]</div>
            </div>
            
            <!-- OPTIMIZATION -->
            <div class="section" id="optimization">
                <h2>⚡ Space & Time Optimization</h2>
                
                <h3>1. Space Optimization Techniques</h3>
                
                <div class="comparison-grid">
                    <div class="card">
                        <h3>Rolling Array</h3>
                        <p>Use only last few rows/states</p>
                        <p><strong>Savings:</strong> O(n²) → O(n)</p>
                        <p><em>Example: 2D DP → 1D array</em></p>
                    </div>
                    <div class="card">
                        <h3>State Variables</h3>
                        <p>Track only necessary values</p>
                        <p><strong>Savings:</strong> O(n) → O(1)</p>
                        <p><em>Example: Fibonacci with 2 vars</em></p>
                    </div>
                    <div class="card">
                        <h3>In-place Modification</h3>
                        <p>Use input array as DP table</p>
                        <p><strong>Savings:</strong> O(n) → O(1)</p>
                        <p><em>Example: Min Path Sum</em></p>
                    </div>
                    <div class="card">
                        <h3>Backward Traversal</h3>
                        <p>Prevent overwriting needed values</p>
                        <p><strong>Savings:</strong> Enables 1D optimization</p>
                        <p><em>Example: 0/1 Knapsack</em></p>
                    </div>
                </div>
                
                <h3>2. Time Optimization Techniques</h3>
                
                <table>
                    <tr>
                        <th>Technique</th>
                        <th>Description</th>
                        <th>Example</th>
                    </tr>
                    <tr>
                        <td><strong>Monotonic Queue</strong></td>
                        <td>Maintain min/max in sliding window</td>
                        <td>Sliding Window Maximum</td>
                    </tr>
                    <tr>
                        <td><strong>Binary Search</strong></td>
                        <td>Find transition points faster</td>
                        <td>LIS O(n²) → O(n log n)</td>
                    </tr>
                    <tr>
                        <td><strong>Prefix Sums</strong></td>
                        <td>Precompute range sums</td>
                        <td>Range Sum Query</td>
                    </tr>
                    <tr>
                        <td><strong>Matrix Exponentiation</strong></td>
                        <td>For linear recurrences</td>
                        <td>Fibonacci O(n) → O(log n)</td>
                    </tr>
                </table>
                
                <h3>Before & After Optimization Example</h3>
                
<div class="code-block"><span class="comment"># BEFORE: O(n) space</span>
<span class="keyword">def</span> <span class="function">fib_dp</span>(n):
    dp = [0] * (n + 1)
    dp[1] = 1
    <span class="keyword">for</span> i <span class="keyword">in</span> range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    <span class="keyword">return</span> dp[n]

<span class="comment"># AFTER: O(1) space</span>
<span class="keyword">def</span> <span class="function">fib_optimized</span>(n):
    <span class="keyword">if</span> n <= 1:
        <span class="keyword">return</span> n
    prev2, prev1 = 0, 1
    <span class="keyword">for</span> _ <span class="keyword">in</span> range(2, n + 1):
        curr = prev1 + prev2
        prev2, prev1 = prev1, curr
    <span class="keyword">return</span> prev1

<span class="comment"># FASTEST: O(log n) using matrix exponentiation</span>
<span class="keyword">def</span> <span class="function">fib_matrix</span>(n):
    <span class="keyword">def</span> <span class="function">matrix_mult</span>(A, B):
        <span class="keyword">return</span> [
            [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],
            [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]
        ]
    
    <span class="keyword">def</span> <span class="function">matrix_pow</span>(M, n):
        <span class="keyword">if</span> n == 1:
            <span class="keyword">return</span> M
        <span class="keyword">if</span> n % 2 == 0:
            half = matrix_pow(M, n // 2)
            <span class="keyword">return</span> matrix_mult(half, half)
        <span class="keyword">return</span> matrix_mult(M, matrix_pow(M, n - 1))
    
    <span class="keyword">if</span> n <= 1:
        <span class="keyword">return</span> n
    M = [[1, 1], [1, 0]]
    result = matrix_pow(M, n)
    <span class="keyword">return</span> result[0][1]</div>

                <h3>DP Optimization Checklist</h3>
                
                <div class="success-box">
                    <h4>✅ Before Coding DP:</h4>
                    <ol>
                        <li><strong>Identify overlapping subproblems</strong> - Do we solve same thing multiple times?</li>
                        <li><strong>Define state clearly</strong> - What information do we need to track?</li>
                        <li><strong>Write recurrence relation</strong> - How do we compute dp[i] from previous states?</li>
                        <li><strong>Determine base cases</strong> - What are the simplest cases?</li>
                        <li><strong>Choose approach</strong> - Top-down or bottom-up?</li>
                        <li><strong>Optimize space</strong> - Can we reduce dimensions?</li>
                    </ol>
                </div>
                
                <h3>Common DP Mistakes</h3>
                
                <div class="warning-box">
                    <h4>⚠️ Watch Out For:</h4>
                    <ul>
                        <li><strong>Off-by-one errors</strong> - Careful with array indices and ranges</li>
                        <li><strong>Wrong initialization</strong> - Initialize with correct base values (0, 1, ∞, etc.)</li>
                        <li><strong>Wrong iteration order</strong> - Must compute dependencies first</li>
                        <li><strong>Forgetting edge cases</strong> - Empty input, single element, etc.</li>
                        <li><strong>Integer overflow</strong> - Use modulo for large counts</li>
                        <li><strong>Not optimizing space</strong> - When only recent states matter</li>
                    </ul>
                </div>
                
                <h3>Time & Space Complexity Summary</h3>
                
                <table>
                    <tr>
                        <th>Problem Type</th>
                        <th>Typical Time</th>
                        <th>Typical Space</th>
                        <th>Can Optimize To</th>
                    </tr>
                    <tr>
                        <td><strong>1D DP</strong></td>
                        <td>O(n)</td>
                        <td>O(n)</td>
                        <td>O(1) space</td>
                    </tr>
                    <tr>
                        <td><strong>2D DP (sequences)</strong></td>
                        <td>O(n²)</td>
                        <td>O(n²)</td>
                        <td>O(n) space</td>
                    </tr>
                    <tr>
                        <td><strong>Knapsack</strong></td>
                        <td>O(n*W)</td>
                        <td>O(n*W)</td>
                        <td>O(W) space</td>
                    </tr>
                    <tr>
                        <td><strong>Grid DP</strong></td>
                        <td>O(m*n)</td>
                        <td>O(m*n)</td>
                        <td>O(n) or O(1) space</td>
                    </tr>
                    <tr>
                        <td><strong>Interval DP</strong></td>
                        <td>O(n³)</td>
                        <td>O(n²)</td>
                        <td>Usually can't optimize</td>
                    </tr>
                    <tr>
                        <td><strong>Bitmask DP</strong></td>
                        <td>O(n * 2ⁿ)</td>
                        <td>O(2ⁿ)</td>
                        <td>Usually can't optimize</td>
                    </tr>
                    <tr>
                        <td><strong>Tree DP</strong></td>
                        <td>O(n)</td>
                        <td>O(n)</td>
                        <td>Sometimes O(1) space</td>
                    </tr>
                </table>
                
                <h3>Complete DP Problem Solving Template</h3>
                
<div class="code-block"><span class="comment">"""
Step-by-step DP Problem Solving Template
"""</span>

<span class="comment"># Step 1: Understand the problem</span>
<span class="comment"># - What are we optimizing? (max/min/count)</span>
<span class="comment"># - What are the constraints?</span>
<span class="comment"># - What choices do we have at each step?</span>

<span class="comment"># Step 2: Define the state</span>
<span class="comment"># dp[i] = ?</span>
<span class="comment"># dp[i][j] = ?</span>
<span class="comment"># Example: dp[i] = maximum profit with first i items</span>

<span class="comment"># Step 3: Write the recurrence relation</span>
<span class="comment"># How does dp[i] relate to previous states?</span>
<span class="comment"># Example: dp[i] = max(dp[i-1], dp[i-2] + nums[i])</span>

<span class="comment"># Step 4: Identify base cases</span>
<span class="comment"># What are the simplest subproblems?</span>
<span class="comment"># Example: dp[0] = nums[0], dp[1] = max(nums[0], nums[1])</span>

<span class="comment"># Step 5: Determine computation order</span>
<span class="comment"># Bottom-up: smallest to largest</span>
<span class="comment"># Top-down: use memoization</span>

<span class="comment"># Step 6: Implement</span>
<span class="keyword">def</span> <span class="function">solve_dp_problem</span>(input_params):
    <span class="comment"># Initialize DP table</span>
    dp = initialize_dp_table()
    
    <span class="comment"># Set base cases</span>
    dp[base_case] = base_value
    
    <span class="comment"># Fill DP table</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(...):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(...):
            dp[i][j] = recurrence_relation()
    
    <span class="comment"># Return final answer</span>
    <span class="keyword">return</span> dp[final_state]

<span class="comment"># Step 7: Optimize space if possible</span>
<span class="keyword">def</span> <span class="function">solve_dp_optimized</span>(input_params):
    <span class="comment"># Use rolling array or state variables</span>
    prev = ...
    curr = ...
    
    <span class="keyword">for</span> i <span class="keyword">in</span> range(...):
        <span class="comment"># Update only necessary states</span>
        curr = compute_from(prev)
        prev = curr
    
    <span class="keyword">return</span> curr</div>

                <h3>Advanced Topics</h3>
                
                <div class="comparison-grid">
                    <div class="card">
                        <h3>Digit DP</h3>
                        <p>Count numbers with specific properties in a range</p>
                        <p><em>Example: Count numbers with digit sum divisible by 3</em></p>
                    </div>
                    <div class="card">
                        <h3>DP on Trees</h3>
                        <p>Solve problems on tree structures</p>
                        <p><em>Example: Tree diameter, maximum path sum</em></p>
                    </div>
                    <div class="card">
                        <h3>DP with Data Structures</h3>
                        <p>Combine DP with segment trees, BIT</p>
                        <p><em>Example: Range DP queries</em></p>
                    </div>
                    <div class="card">
                        <h3>Probability DP</h3>
                        <p>Calculate probabilities using DP</p>
                        <p><em>Example: Expected value problems</em></p>
                    </div>
                </div>
                
                <h3>Practice Problem Categories</h3>
                
                <div class="info-box">
                    <h4>🎯 Beginner Level:</h4>
                    <ul>
                        <li>Climbing Stairs</li>
                        <li>House Robber</li>
                        <li>Maximum Subarray</li>
                        <li>Coin Change</li>
                        <li>Unique Paths</li>
                    </ul>
                    
                    <h4>🎯 Intermediate Level:</h4>
                    <ul>
                        <li>Longest Common Subsequence</li>
                        <li>Edit Distance</li>
                        <li>0/1 Knapsack</li>
                        <li>Word Break</li>
                        <li>Longest Increasing Subsequence</li>
                    </ul>
                    
                    <h4>🎯 Advanced Level:</h4>
                    <ul>
                        <li>Burst Balloons</li>
                        <li>Regular Expression Matching</li>
                        <li>Wildcard Matching</li>
                        <li>Palindrome Partitioning</li>
                        <li>Interleaving String</li>
                    </ul>
                    
                    <h4>🎯 Expert Level:</h4>
                    <ul>
                        <li>Distinct Subsequences</li>
                        <li>Stone Game series</li>
                        <li>Maximum Profit in Job Scheduling</li>
                        <li>Concatenated Words</li>
                        <li>Count Different Palindromic Subsequences</li>
                    </ul>
                </div>
                
                <h3>Final Tips & Tricks</h3>
                
                <div class="success-box">
                    <h4>💡 Pro Tips:</h4>
                    <ol>
                        <li><strong>Draw it out:</strong> Visualize DP table with small examples</li>
                        <li><strong>Start simple:</strong> Get brute force working first, then optimize</li>
                        <li><strong>Trace execution:</strong> Manually compute first few values</li>
                        <li><strong>Check boundaries:</strong> Verify base cases and edge cases</li>
                        <li><strong>Space optimization last:</strong> Get correctness first, optimize later</li>
                        <li><strong>Use meaningful names:</strong> Name states clearly (not just i, j)</li>
                        <li><strong>Add comments:</strong> Document what each state represents</li>
                        <li><strong>Test incrementally:</strong> Test each component separately</li>
                    </ol>
                </div>
                
                <h3>Common Interview Questions</h3>
                
                <table>
                    <tr>
                        <th>Problem</th>
                        <th>Pattern</th>
                        <th>Time</th>
                        <th>Key Insight</th>
                    </tr>
                    <tr>
                        <td><strong>Climbing Stairs</strong></td>
                        <td>Linear</td>
                        <td>O(n)</td>
                        <td>Fibonacci-like recurrence</td>
                    </tr>
                    <tr>
                        <td><strong>House Robber</strong></td>
                        <td>Linear</td>
                        <td>O(n)</td>
                        <td>Rob current or skip</td>
                    </tr>
                    <tr>
                        <td><strong>Coin Change</strong></td>
                        <td>Knapsack</td>
                        <td>O(n*m)</td>
                        <td>Unbounded knapsack variant</td>
                    </tr>
                    <tr>
                        <td><strong>LCS</strong></td>
                        <td>2 Sequences</td>
                        <td>O(n²)</td>
                        <td>Match or skip characters</td>
                    </tr>
                    <tr>
                        <td><strong>Edit Distance</strong></td>
                        <td>2 Sequences</td>
                        <td>O(n²)</td>
                        <td>Insert/delete/replace ops</td>
                    </tr>
                    <tr>
                        <td><strong>Unique Paths</strong></td>
                        <td>Grid</td>
                        <td>O(m*n)</td>
                        <td>Sum from top and left</td>
                    </tr>
                    <tr>
                        <td><strong>Max Subarray</strong></td>
                        <td>Linear</td>
                        <td>O(n)</td>
                        <td>Kadane's algorithm</td>
                    </tr>
                    <tr>
                        <td><strong>Word Break</strong></td>
                        <td>Linear</td>
                        <td>O(n²)</td>
                        <td>Check all prefixes</td>
                    </tr>
                    <tr>
                        <td><strong>LIS</strong></td>
                        <td>Linear</td>
                        <td>O(n log n)</td>
                        <td>Binary search optimization</td>
                    </tr>
                    <tr>
                        <td><strong>Burst Balloons</strong></td>
                        <td>Interval</td>
                        <td>O(n³)</td>
                        <td>Think backwards (burst last)</td>
                    </tr>
                </table>
                
                <h3>Quick Reference: When to Use What</h3>
                
                <div class="highlight-box">
                    <h4>Decision Tree:</h4>
                    <ul>
                        <li><strong>Sequential decisions?</strong> → 1D DP (Fibonacci, House Robber)</li>
                        <li><strong>Two sequences/strings?</strong> → 2D DP (LCS, Edit Distance)</li>
                        <li><strong>Grid movement?</strong> → 2D Grid DP (Unique Paths)</li>
                        <li><strong>Selecting items with weight?</strong> → Knapsack pattern</li>
                        <li><strong>Range/interval problems?</strong> → Interval DP (Burst Balloons)</li>
                        <li><strong>State transitions?</strong> → State Machine DP (Stock Trading)</li>
                        <li><strong>Small n, subset selection?</strong> → Bitmask DP (TSP)</li>
                        <li><strong>Tree structure?</strong> → Tree DP (Tree Diameter)</li>
                    </ul>
                </div>
            </div>
            
            <!-- CONCLUSION -->
            <div class="section">
                <h2>🎓 Conclusion</h2>
                
                <div class="visual-example">
                    <h3>The DP Journey</h3>
                    <ol style="font-size: 1.1em; line-height: 2;">
                        <li><strong>Recognize the pattern</strong> - Overlapping subproblems + Optimal substructure</li>
                        <li><strong>Define the state</strong> - What information do we need?</li>
                        <li><strong>Write recurrence</strong> - How to combine subproblems?</li>
                        <li><strong>Handle base cases</strong> - Simplest scenarios</li>
                        <li><strong>Choose approach</strong> - Top-down or bottom-up?</li>
                        <li><strong>Implement & test</strong> - Get it working</li>
                        <li><strong>Optimize</strong> - Reduce space/time if possible</li>
                    </ol>
                </div>
                
                <div class="success-box">
                    <h3>🌟 Key Takeaways</h3>
                    <ul>
                        <li><strong>DP is about avoiding repeated work</strong> by storing results</li>
                        <li><strong>Not all recursive problems need DP</strong> - must have overlapping subproblems</li>
                        <li><strong>Start with brute force recursion</strong>, add memoization, then optimize</li>
                        <li><strong>Drawing DP tables helps</strong> visualize the solution</li>
                        <li><strong>Space can often be optimized</strong> by using rolling arrays</li>
                        <li><strong>Practice is essential</strong> - patterns become obvious with experience</li>
                    </ul>
                </div>
                
                <div class="info-box">
                    <h3>📚 Further Resources</h3>
                    <ul>
                        <li>Practice on LeetCode, Codeforces, AtCoder</li>
                        <li>Study classic DP problems category by category</li>
                        <li>Understand why greedy doesn't work (helps recognize DP)</li>
                        <li>Learn related topics: Graph DP, Digit DP, Probability DP</li>
                        <li>Read editorials and different approaches</li>
                    </ul>
                </div>
                
                <div class="highlight-box" style="text-align: center; font-size: 1.2em;">
                    <p><strong>Remember:</strong> Dynamic Programming is not magic - it's systematic problem solving!</p>
                    <p style="margin-top: 15px;">Break problems into subproblems, store results, build up solutions. 🚀</p>
                </div>
            </div>
        </div>
    </div>
</body>
</html><!DOCTYPE html>
