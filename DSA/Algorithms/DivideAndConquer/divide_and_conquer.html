<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Divide and Conquer - Complete Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: #333;
            padding: 20px;
            line-height: 1.7;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 50px;
            text-align: center;
        }
        
        h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .subtitle {
            font-size: 1.3em;
            opacity: 0.95;
        }
        
        nav {
            background: #f8f9fa;
            padding: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .nav-links {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .nav-links a {
            padding: 10px 20px;
            background: white;
            color: #f5576c;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .nav-links a:hover {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            transform: translateY(-2px);
        }
        
        .content {
            padding: 50px;
        }
        
        .section {
            margin-bottom: 50px;
            padding: 40px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 6px solid #f5576c;
        }
        
        h2 {
            color: #f5576c;
            margin-bottom: 25px;
            font-size: 2.2em;
            border-bottom: 3px solid #f5576c;
            padding-bottom: 10px;
        }
        
        h3 {
            color: #f093fb;
            margin: 25px 0 15px 0;
            font-size: 1.6em;
        }
        
        h4 {
            color: #e91e63;
            margin: 20px 0 10px 0;
            font-size: 1.3em;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 25px;
            border-radius: 12px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.6;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            white-space: pre;
        }
        
        .code-block .comment {
            color: #95a5a6;
        }
        
        .code-block .keyword {
            color: #3498db;
        }
        
        .code-block .string {
            color: #e74c3c;
        }
        
        .code-block .function {
            color: #f39c12;
        }
        
        .visual-flow {
            background: white;
            padding: 25px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .visual-flow pre {
            margin: 10px 0;
            line-height: 1.8;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .card {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            border-top: 4px solid #f5576c;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }
        
        .highlight-box {
            background: linear-gradient(135deg, #ffe5f0 0%, #fff0f5 100%);
            border-left: 5px solid #f5576c;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .warning-box {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .info-box {
            background: #d1ecf1;
            border-left: 5px solid #17a2b8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .success-box {
            background: #d4edda;
            border-left: 5px solid #28a745;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        
        th {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 15px;
            border-bottom: 1px solid #ecf0f1;
        }
        
        tr:hover {
            background: #f8f9fa;
        }
        
        code {
            background: #f4f4f4;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #e74c3c;
            font-size: 0.9em;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-top: 15px;
        }
        
        li {
            margin: 10px 0;
        }
        
        strong {
            color: #f5576c;
        }
        
        .pattern-box {
            background: white;
            border: 3px solid #f093fb;
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
        }
        
        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }
            
            .section {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>⚔️ Divide and Conquer</h1>
            <p class="subtitle">Master the Ultimate Problem-Solving Strategy</p>
        </header>
        
        <nav>
            <div class="nav-links">
                <a href="#basics">Basics</a>
                <a href="#paradigm">Paradigm</a>
                <a href="#examples">Classic Examples</a>
                <a href="#algorithms">Algorithms</a>
                <a href="#patterns">Patterns</a>
                <a href="#problems">Problems</a>
                <a href="#tips">Tips</a>
            </div>
        </nav>
        
        <div class="content">
            <!-- BASICS -->
            <div class="section" id="basics">
                <h2>🎯 What is Divide and Conquer?</h2>
                <p><strong>Divide and Conquer</strong> is an algorithmic paradigm that breaks down a problem into smaller subproblems of the same type, solves them recursively, and combines their solutions to solve the original problem.</p>
                
                <div class="highlight-box">
                    <h4>🔑 The Three Steps:</h4>
                    <ol style="font-size: 1.2em;">
                        <li><strong>DIVIDE:</strong> Break the problem into smaller subproblems</li>
                        <li><strong>CONQUER:</strong> Solve the subproblems recursively</li>
                        <li><strong>COMBINE:</strong> Merge the solutions to solve original problem</li>
                    </ol>
                </div>
                
                <div class="visual-flow">
                    <h4>Visual Representation:</h4>
                    <pre>
                    Original Problem (size n)
                            |
                    ┌───────┴───────┐
                    |   DIVIDE      |
                    └───────┬───────┘
                            |
                ┌───────────┴───────────┐
                |                       |
        Subproblem 1              Subproblem 2
        (size n/2)                (size n/2)
                |                       |
        ┌───────┴───────┐       ┌───────┴───────┐
        |   CONQUER     |       |   CONQUER     |
        └───────┬───────┘       └───────┬───────┘
                |                       |
        Solution 1              Solution 2
                |                       |
                └───────────┬───────────┘
                            |
                    ┌───────┴───────┐
                    |   COMBINE     |
                    └───────┬───────┘
                            |
                    Final Solution
                    </pre>
                </div>
                
                <h3>Simple Example: Find Maximum in Array</h3>
                <div class="visual-flow">
                    <pre>
<strong>Problem:</strong> Find maximum in [3, 7, 2, 9, 5, 1, 8, 4]

<strong>Step 1: DIVIDE</strong>
[3, 7, 2, 9, 5, 1, 8, 4]
        ↓ Split in half
[3, 7, 2, 9]    [5, 1, 8, 4]
        ↓               ↓
[3, 7] [2, 9]   [5, 1] [8, 4]
   ↓      ↓        ↓      ↓
[3][7] [2][9]   [5][1] [8][4]  ← Base case (single elements)

<strong>Step 2: CONQUER (Base case returns the element)</strong>
3   7   2   9    5   1   8   4

<strong>Step 3: COMBINE (Take maximum of pairs)</strong>
[3][7] → max(3,7) = 7
[2][9] → max(2,9) = 9
[5][1] → max(5,1) = 5
[8][4] → max(8,4) = 8

Level up:
[7, 9] → max(7,9) = 9
[5, 8] → max(5,8) = 8

Final:
[9, 8] → max(9,8) = <span style="color: #28a745;">9</span> ✓ Answer!
                    </pre>
                </div>
                
                <h3>Implementation</h3>
<div class="code-block"><span class="keyword">def</span> <span class="function">find_max</span>(arr, left, right):
    <span class="comment">"""
    Find maximum using Divide and Conquer
    Time: O(n), Space: O(log n) for recursion stack
    """</span>
    <span class="comment"># Base case: single element</span>
    <span class="keyword">if</span> left == right:
        <span class="keyword">return</span> arr[left]
    
    <span class="comment"># DIVIDE: Find middle point</span>
    mid = left + (right - left) // 2
    
    <span class="comment"># CONQUER: Recursively find max in both halves</span>
    max_left = find_max(arr, left, mid)
    max_right = find_max(arr, mid + 1, right)
    
    <span class="comment"># COMBINE: Return maximum of two</span>
    <span class="keyword">return</span> max(max_left, max_right)

<span class="comment"># Test</span>
arr = [3, 7, 2, 9, 5, 1, 8, 4]
print(find_max(arr, 0, len(arr)-1))  <span class="comment"># Output: 9</span></div>

                <h3>Comparison with Other Approaches</h3>
                <table>
                    <tr>
                        <th>Approach</th>
                        <th>Time</th>
                        <th>Space</th>
                        <th>When to Use</th>
                    </tr>
                    <tr>
                        <td><strong>Brute Force</strong></td>
                        <td>O(n)</td>
                        <td>O(1)</td>
                        <td>Simple problems, small data</td>
                    </tr>
                    <tr>
                        <td><strong>Divide & Conquer</strong></td>
                        <td>O(n log n) typical</td>
                        <td>O(log n)</td>
                        <td>Sorting, searching, optimization</td>
                    </tr>
                    <tr>
                        <td><strong>Dynamic Programming</strong></td>
                        <td>O(n²) typical</td>
                        <td>O(n)</td>
                        <td>Overlapping subproblems</td>
                    </tr>
                    <tr>
                        <td><strong>Greedy</strong></td>
                        <td>O(n log n)</td>
                        <td>O(1)</td>
                        <td>Local optimal = global optimal</td>
                    </tr>
                </table>
            </div>
            
            <!-- PARADIGM -->
            <div class="section" id="paradigm">
                <h2>📐 The Divide and Conquer Paradigm</h2>
                
                <h3>General Template</h3>
<div class="code-block"><span class="keyword">def</span> <span class="function">divide_and_conquer</span>(problem):
    <span class="comment">"""Generic Divide and Conquer template"""</span>
    
    <span class="comment"># BASE CASE: Problem small enough to solve directly</span>
    <span class="keyword">if</span> is_base_case(problem):
        <span class="keyword">return</span> solve_directly(problem)
    
    <span class="comment"># DIVIDE: Break into subproblems</span>
    subproblems = divide(problem)
    
    <span class="comment"># CONQUER: Solve each subproblem recursively</span>
    sub_solutions = []
    <span class="keyword">for</span> subproblem <span class="keyword">in</span> subproblems:
        sub_solutions.append(divide_and_conquer(subproblem))
    
    <span class="comment"># COMBINE: Merge solutions</span>
    solution = combine(sub_solutions)
    
    <span class="keyword">return</span> solution</div>

                <h3>Key Characteristics</h3>
                <div class="comparison-grid">
                    <div class="card">
                        <h3>✅ When to Use D&C</h3>
                        <ul>
                            <li>Problem can be divided into similar subproblems</li>
                            <li>Subproblems are independent</li>
                            <li>Optimal substructure exists</li>
                            <li>Combining solutions is efficient</li>
                        </ul>
                    </div>
                    <div class="card">
                        <h3>❌ When NOT to Use D&C</h3>
                        <ul>
                            <li>Subproblems overlap (use DP instead)</li>
                            <li>Problem too simple (use iteration)</li>
                            <li>Combining is expensive</li>
                            <li>Stack overflow risk on large inputs</li>
                        </ul>
                    </div>
                </div>
                
                <h3>Recurrence Relations</h3>
                <div class="info-box">
                    <h4>Understanding Time Complexity via Recurrences:</h4>
                    <p>Most D&C algorithms follow: <strong>T(n) = aT(n/b) + f(n)</strong></p>
                    <ul>
                        <li><strong>a</strong> = number of subproblems</li>
                        <li><strong>n/b</strong> = size of each subproblem</li>
                        <li><strong>f(n)</strong> = cost of divide + combine steps</li>
                    </ul>
                    
                    <h4>Master Theorem:</h4>
                    <ol>
                        <li><strong>If f(n) = O(n^c) where c < log_b(a):</strong> T(n) = Θ(n^log_b(a))</li>
                        <li><strong>If f(n) = Θ(n^c) where c = log_b(a):</strong> T(n) = Θ(n^c log n)</li>
                        <li><strong>If f(n) = Ω(n^c) where c > log_b(a):</strong> T(n) = Θ(f(n))</li>
                    </ol>
                </div>
                
                <h3>Examples of Recurrence Analysis</h3>
                <table>
                    <tr>
                        <th>Algorithm</th>
                        <th>Recurrence</th>
                        <th>a</th>
                        <th>b</th>
                        <th>f(n)</th>
                        <th>Solution</th>
                    </tr>
                    <tr>
                        <td><strong>Binary Search</strong></td>
                        <td>T(n) = T(n/2) + O(1)</td>
                        <td>1</td>
                        <td>2</td>
                        <td>O(1)</td>
                        <td>O(log n)</td>
                    </tr>
                    <tr>
                        <td><strong>Merge Sort</strong></td>
                        <td>T(n) = 2T(n/2) + O(n)</td>
                        <td>2</td>
                        <td>2</td>
                        <td>O(n)</td>
                        <td>O(n log n)</td>
                    </tr>
                    <tr>
                        <td><strong>Quick Sort (avg)</strong></td>
                        <td>T(n) = 2T(n/2) + O(n)</td>
                        <td>2</td>
                        <td>2</td>
                        <td>O(n)</td>
                        <td>O(n log n)</td>
                    </tr>
                    <tr>
                        <td><strong>Strassen's Matrix</strong></td>
                        <td>T(n) = 7T(n/2) + O(n²)</td>
                        <td>7</td>
                        <td>2</td>
                        <td>O(n²)</td>
                        <td>O(n^2.807)</td>
                    </tr>
                </table>
            </div>
            
            <!-- CLASSIC EXAMPLES -->
            <div class="section" id="examples">
                <h2>📚 Classic Divide and Conquer Examples</h2>
                
                <h3>1. Binary Search</h3>
                <p>Search in sorted array by repeatedly dividing search space in half</p>
                
                <div class="visual-flow">
                    <h4>Visual: Search for 7 in [1, 3, 5, 7, 9, 11, 13]</h4>
                    <pre>
<strong>Initial:</strong> [1, 3, 5, 7, 9, 11, 13]  Target = 7
                     ↑
                    mid=7

Compare 7 == 7? YES! Found at index 3 ✓

<strong>Another example: Search for 11</strong>
[1, 3, 5, 7, 9, 11, 13]  mid=7, 11>7, search right
           [9, 11, 13]  mid=11, 11==11, Found! ✓

<strong>Recurrence:</strong> T(n) = T(n/2) + O(1) = O(log n)
                    </pre>
                </div>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">binary_search</span>(arr, target, left, right):
    <span class="comment">"""Binary Search using Divide and Conquer"""</span>
    <span class="comment"># Base case: not found</span>
    <span class="keyword">if</span> left > right:
        <span class="keyword">return</span> -1
    
    <span class="comment"># DIVIDE: Find middle</span>
    mid = left + (right - left) // 2
    
    <span class="comment"># Base case: found</span>
    <span class="keyword">if</span> arr[mid] == target:
        <span class="keyword">return</span> mid
    
    <span class="comment"># CONQUER: Search in appropriate half</span>
    <span class="keyword">if</span> arr[mid] < target:
        <span class="keyword">return</span> binary_search(arr, target, mid + 1, right)
    <span class="keyword">else</span>:
        <span class="keyword">return</span> binary_search(arr, target, left, mid - 1)</div>

                <h3>2. Merge Sort</h3>
                <p>Divide array in half, sort each half, merge sorted halves</p>
                
                <div class="visual-flow">
                    <h4>Visual: Sort [38, 27, 43, 3, 9, 82, 10]</h4>
                    <pre>
<strong>DIVIDE PHASE:</strong>
[38, 27, 43, 3, 9, 82, 10]
        ↓ Split
[38, 27, 43, 3]    [9, 82, 10]
        ↓                ↓
[38, 27] [43, 3]    [9, 82] [10]
   ↓        ↓          ↓
[38][27] [43][3]   [9][82] [10]  ← Base case

<strong>CONQUER & COMBINE PHASE:</strong>
[38][27] → <span style="color: #28a745;">[27, 38]</span>  (merge)
[43][3]  → <span style="color: #28a745;">[3, 43]</span>   (merge)
[9][82]  → <span style="color: #28a745;">[9, 82]</span>   (merge)
[10]     → <span style="color: #28a745;">[10]</span>      (already sorted)

[27, 38] + [3, 43]  → <span style="color: #28a745;">[3, 27, 38, 43]</span>
[9, 82] + [10]      → <span style="color: #28a745;">[9, 10, 82]</span>

[3, 27, 38, 43] + [9, 10, 82] → <span style="color: #28a745;">[3, 9, 10, 27, 38, 43, 82]</span> ✓

<strong>Recurrence:</strong> T(n) = 2T(n/2) + O(n) = O(n log n)
                    </pre>
                </div>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">merge_sort</span>(arr):
    <span class="comment">"""Merge Sort using Divide and Conquer"""</span>
    <span class="comment"># Base case</span>
    <span class="keyword">if</span> len(arr) <= 1:
        <span class="keyword">return</span> arr
    
    <span class="comment"># DIVIDE: Split array in half</span>
    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]
    
    <span class="comment"># CONQUER: Recursively sort both halves</span>
    left_sorted = merge_sort(left_half)
    right_sorted = merge_sort(right_half)
    
    <span class="comment"># COMBINE: Merge sorted halves</span>
    <span class="keyword">return</span> merge(left_sorted, right_sorted)

<span class="keyword">def</span> <span class="function">merge</span>(left, right):
    <span class="comment">"""Merge two sorted arrays"""</span>
    result = []
    i = j = 0
    
    <span class="keyword">while</span> i < len(left) <span class="keyword">and</span> j < len(right):
        <span class="keyword">if</span> left[i] <= right[j]:
            result.append(left[i])
            i += 1
        <span class="keyword">else</span>:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    <span class="keyword">return</span> result</div>

                <h3>3. Quick Sort</h3>
                <p>Pick pivot, partition around it, sort partitions</p>
                
                <div class="visual-flow">
                    <h4>Visual: Sort [10, 7, 8, 9, 1, 5]</h4>
                    <pre>
<strong>Step 1: Partition around pivot (5)</strong>
[10, 7, 8, 9, 1, <span style="color: #f5576c;">5</span>]
All < 5: [1]  Pivot: [5]  All > 5: [10, 7, 8, 9]

<strong>Step 2: Recursively sort left and right</strong>
Left: [1] → already sorted
Right: [10, 7, 8, 9] → partition around 9
  [7, 8, <span style="color: #f5576c;">9</span>, 10]
  [7, 8] | 9 | [10]
  
Continue until all sorted...

<strong>Final:</strong> <span style="color: #28a745;">[1, 5, 7, 8, 9, 10]</span> ✓

<strong>Recurrence:</strong> 
Average: T(n) = 2T(n/2) + O(n) = O(n log n)
Worst: T(n) = T(n-1) + O(n) = O(n²)
                    </pre>
                </div>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">quick_sort</span>(arr, low=0, high=<span class="keyword">None</span>):
    <span class="comment">"""Quick Sort using Divide and Conquer"""</span>
    <span class="keyword">if</span> high <span class="keyword">is None</span>:
        high = len(arr) - 1
    
    <span class="keyword">if</span> low < high:
        <span class="comment"># DIVIDE: Partition and get pivot index</span>
        pivot_idx = partition(arr, low, high)
        
        <span class="comment"># CONQUER: Sort left and right of pivot</span>
        quick_sort(arr, low, pivot_idx - 1)
        quick_sort(arr, pivot_idx + 1, high)
    
    <span class="keyword">return</span> arr

<span class="keyword">def</span> <span class="function">partition</span>(arr, low, high):
    pivot = arr[high]
    i = low - 1
    
    <span class="keyword">for</span> j <span class="keyword">in</span> range(low, high):
        <span class="keyword">if</span> arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    <span class="keyword">return</span> i + 1</div>

                <h3>4. Power Calculation (Fast Exponentiation)</h3>
                <p>Calculate x^n efficiently using divide and conquer</p>                
                <div class="visual-flow">
                    <h4>Visual: Calculate 2^10</h4>
                    <pre>
<strong>Naive approach:</strong> 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 = 10 multiplications

<strong>Divide and Conquer:</strong>
2^10 = (2^5)^2
2^5 = 2 * (2^4) = 2 * (2^2)^2
2^2 = (2^1)^2
2^1 = 2

Building back up:
2^1 = 2
2^2 = 2 * 2 = 4
2^4 = 4 * 4 = 16
2^5 = 2 * 16 = 32
2^10 = 32 * 32 = 1024 ✓

<strong>Only 4 multiplications instead of 10!</strong>

<strong>Recurrence:</strong> T(n) = T(n/2) + O(1) = O(log n)
                    </pre>
                </div>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">power</span>(x, n):
    <span class="comment">"""
    Calculate x^n using Divide and Conquer
    Time: O(log n), Space: O(log n)
    """</span>
    <span class="comment"># Base cases</span>
    <span class="keyword">if</span> n == 0:
        <span class="keyword">return</span> 1
    <span class="keyword">if</span> n == 1:
        <span class="keyword">return</span> x
    
    <span class="comment"># DIVIDE: Calculate x^(n/2)</span>
    half = power(x, n // 2)
    
    <span class="comment"># COMBINE: Square the result</span>
    <span class="keyword">if</span> n % 2 == 0:
        <span class="keyword">return</span> half * half
    <span class="keyword">else</span>:
        <span class="keyword">return</span> x * half * half

<span class="comment"># Handle negative exponents</span>
<span class="keyword">def</span> <span class="function">power_with_negatives</span>(x, n):
    <span class="keyword">if</span> n < 0:
        <span class="keyword">return</span> 1 / power(x, -n)
    <span class="keyword">return</span> power(x, n)

print(power(2, 10))  <span class="comment"># Output: 1024</span>
print(power(3, 5))   <span class="comment"># Output: 243</span></div>

                <h3>5. Maximum Subarray (Kadane-like D&C)</h3>
                <p>Find contiguous subarray with maximum sum</p>
                
                <div class="visual-flow">
                    <h4>Visual: [-2, 1, -3, 4, -1, 2, 1, -5, 4]</h4>
                    <pre>
<strong>Divide array into left and right halves</strong>
Left half: [-2, 1, -3, 4]    Right half: [-1, 2, 1, -5, 4]

<strong>Three cases:</strong>
1. Max subarray entirely in left half
2. Max subarray entirely in right half  
3. Max subarray crosses the middle

<strong>For crossing subarray:</strong>
Find max sum from middle going left: [4, -3, 1, -2]
Find max sum from middle going right: [-1, 2, 1]
Crossing sum = 4 + (-1 + 2 + 1) = 6

<strong>Recursively solve left and right, compare all three</strong>
Left max: 4
Right max: 4
Crossing max: 6

<strong>Answer: 6</strong> (subarray [4, -1, 2, 1])
                    </pre>
                </div>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">max_subarray</span>(arr, left, right):
    <span class="comment">"""Maximum Subarray using Divide and Conquer"""</span>
    <span class="comment"># Base case: single element</span>
    <span class="keyword">if</span> left == right:
        <span class="keyword">return</span> arr[left]
    
    <span class="comment"># DIVIDE: Find middle</span>
    mid = left + (right - left) // 2
    
    <span class="comment"># CONQUER: Find max in left and right halves</span>
    left_max = max_subarray(arr, left, mid)
    right_max = max_subarray(arr, mid + 1, right)
    
    <span class="comment"># COMBINE: Find max crossing subarray</span>
    cross_max = max_crossing_subarray(arr, left, mid, right)
    
    <span class="comment"># Return maximum of three</span>
    <span class="keyword">return</span> max(left_max, right_max, cross_max)

<span class="keyword">def</span> <span class="function">max_crossing_subarray</span>(arr, left, mid, right):
    <span class="comment">"""Find max subarray that crosses the middle"""</span>
    <span class="comment"># Find max sum from mid to left</span>
    left_sum = float(<span class="string">'-inf'</span>)
    curr_sum = 0
    <span class="keyword">for</span> i <span class="keyword">in</span> range(mid, left - 1, -1):
        curr_sum += arr[i]
        left_sum = max(left_sum, curr_sum)
    
    <span class="comment"># Find max sum from mid+1 to right</span>
    right_sum = float(<span class="string">'-inf'</span>)
    curr_sum = 0
    <span class="keyword">for</span> i <span class="keyword">in</span> range(mid + 1, right + 1):
        curr_sum += arr[i]
        right_sum = max(right_sum, curr_sum)
    
    <span class="keyword">return</span> left_sum + right_sum

<span class="comment"># Test</span>
arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_subarray(arr, 0, len(arr) - 1))  <span class="comment"># Output: 6</span></div>
            </div>
            
            <!-- ALGORITHMS -->
            <div class="section" id="algorithms">
                <h2>⚙️ More D&C Algorithms</h2>
                
                <h3>6. Count Inversions</h3>
                <p>Count pairs (i, j) where i < j but arr[i] > arr[j]</p>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">count_inversions</span>(arr):
    <span class="comment">"""
    Count inversions using modified Merge Sort
    Time: O(n log n)
    """</span>
    <span class="keyword">if</span> len(arr) <= 1:
        <span class="keyword">return</span> arr, 0
    
    <span class="comment"># DIVIDE</span>
    mid = len(arr) // 2
    left, left_inv = count_inversions(arr[:mid])
    right, right_inv = count_inversions(arr[mid:])
    
    <span class="comment"># COMBINE and count cross inversions</span>
    merged, cross_inv = merge_and_count(left, right)
    
    total_inv = left_inv + right_inv + cross_inv
    <span class="keyword">return</span> merged, total_inv

<span class="keyword">def</span> <span class="function">merge_and_count</span>(left, right):
    <span class="comment">"""Merge and count inversions"""</span>
    result = []
    inversions = 0
    i = j = 0
    
    <span class="keyword">while</span> i < len(left) <span class="keyword">and</span> j < len(right):
        <span class="keyword">if</span> left[i] <= right[j]:
            result.append(left[i])
            i += 1
        <span class="keyword">else</span>:
            result.append(right[j])
            inversions += len(left) - i  <span class="comment"># Count inversions</span>
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    <span class="keyword">return</span> result, inversions

<span class="comment"># Test</span>
arr = [2, 4, 1, 3, 5]
sorted_arr, inv_count = count_inversions(arr)
print(<span class="string">f"Inversions: {inv_count}"</span>)  <span class="comment"># Output: 3 (pairs: (2,1), (4,1), (4,3))</span></div>

                <h3>7. Closest Pair of Points</h3>
                <p>Find the closest pair of points in 2D plane</p>
                
<div class="code-block"><span class="keyword">import</span> math

<span class="keyword">def</span> <span class="function">closest_pair</span>(points):
    <span class="comment">"""
    Find closest pair of points using D&C
    Time: O(n log n)
    """</span>
    <span class="comment"># Sort by x-coordinate</span>
    points_x = sorted(points, key=<span class="keyword">lambda</span> p: p[0])
    <span class="comment"># Sort by y-coordinate</span>
    points_y = sorted(points, key=<span class="keyword">lambda</span> p: p[1])
    
    <span class="keyword">return</span> closest_pair_recursive(points_x, points_y)

<span class="keyword">def</span> <span class="function">closest_pair_recursive</span>(px, py):
    n = len(px)
    
    <span class="comment"># Base case: use brute force for small n</span>
    <span class="keyword">if</span> n <= 3:
        <span class="keyword">return</span> brute_force_closest(px)
    
    <span class="comment"># DIVIDE: Split at middle</span>
    mid = n // 2
    midpoint = px[mid]
    
    <span class="comment"># Split points by y-coordinate</span>
    py_left = [p <span class="keyword">for</span> p <span class="keyword">in</span> py <span class="keyword">if</span> p[0] <= midpoint[0]]
    py_right = [p <span class="keyword">for</span> p <span class="keyword">in</span> py <span class="keyword">if</span> p[0] > midpoint[0]]
    
    <span class="comment"># CONQUER: Find closest in each half</span>
    left_min = closest_pair_recursive(px[:mid], py_left)
    right_min = closest_pair_recursive(px[mid:], py_right)
    
    <span class="comment"># Find minimum of two</span>
    d = min(left_min, right_min)
    
    <span class="comment"># COMBINE: Check points near dividing line</span>
    strip = [p <span class="keyword">for</span> p <span class="keyword">in</span> py <span class="keyword">if</span> abs(p[0] - midpoint[0]) < d]
    strip_min = closest_in_strip(strip, d)
    
    <span class="keyword">return</span> min(d, strip_min)

<span class="keyword">def</span> <span class="function">brute_force_closest</span>(points):
    min_dist = float(<span class="string">'inf'</span>)
    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(points)):
        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + 1, len(points)):
            dist = distance(points[i], points[j])
            min_dist = min(min_dist, dist)
    <span class="keyword">return</span> min_dist

<span class="keyword">def</span> <span class="function">closest_in_strip</span>(strip, d):
    min_dist = d
    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(strip)):
        j = i + 1
        <span class="keyword">while</span> j < len(strip) <span class="keyword">and</span> (strip[j][1] - strip[i][1]) < min_dist:
            min_dist = min(min_dist, distance(strip[i], strip[j]))
            j += 1
    <span class="keyword">return</span> min_dist

<span class="keyword">def</span> <span class="function">distance</span>(p1, p2):
    <span class="keyword">return</span> math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)</div>

                <h3>8. Karatsuba Multiplication</h3>
                <p>Fast multiplication of large numbers</p>
                
                <div class="info-box">
                    <h4>Idea: Multiply two n-digit numbers with only 3 recursive multiplications instead of 4</h4>
                    <p>For x = 5678 and y = 1234:</p>
                    <ul>
                        <li>x = 56 * 10² + 78</li>
                        <li>y = 12 * 10² + 34</li>
                        <li>Traditional: x * y requires 4 multiplications</li>
                        <li>Karatsuba: Only needs 3 multiplications!</li>
                    </ul>
                </div>
                
<div class="code-block"><span class="keyword">def</span> <span class="function">karatsuba</span>(x, y):
    <span class="comment">"""
    Karatsuba multiplication
    Time: O(n^1.585) vs O(n²) for traditional
    """</span>
    <span class="comment"># Base case</span>
    <span class="keyword">if</span> x < 10 <span class="keyword">or</span> y < 10:
        <span class="keyword">return</span> x * y
    
    <span class="comment"># Calculate the size of the numbers</span>
    n = max(len(str(x)), len(str(y)))
    m = n // 2
    
    <span class="comment"># DIVIDE: Split numbers</span>
    power = 10 ** m
    high_x, low_x = divmod(x, power)
    high_y, low_y = divmod(y, power)
    
    <span class="comment"># CONQUER: Three recursive multiplications</span>
    z0 = karatsuba(low_x, low_y)
    z1 = karatsuba(high_x + low_x, high_y + low_y)
    z2 = karatsuba(high_x, high_y)
    
    <span class="comment"># COMBINE</span>
    <span class="keyword">return</span> z2 * (10 ** (2 * m)) + (z1 - z2 - z0) * power + z0

<span class="comment"># Test</span>
print(karatsuba(5678, 1234))  <span class="comment"># Output: 7006652</span></div>
            </div>
            
            <!-- PATTERNS -->
            <div class="section" id="patterns">
                <h2>🧩 Common D&C Patterns</h2>
                
                <h3>Pattern 1: Binary Division</h3>
                <div class="pattern-box">
                    <h4>Recognition:</h4>
                    <ul>
                        <li>Problem can be split into two equal halves</li>
                        <li>Solution in one half or both</li>
                    </ul>
                    <h4>Examples:</h4>
                    <ul>
                        <li>Binary Search</li>
                        <li>Merge Sort</li>
                        <li>Quick Sort</li>
                        <li>Maximum Subarray</li>
                    </ul>
                    <h4>Template:</h4>
<div class="code-block"><span class="keyword">def</span> <span class="function">binary_divide</span>(arr, left, right):
    <span class="keyword">if</span> left >= right:
        <span class="keyword">return</span> base_case(arr[left])
    
    mid = left + (right - left) // 2
    left_result = binary_divide(arr, left, mid)
    right_result = binary_divide(arr, mid + 1, right)
    
    <span class="keyword">return</span> combine(left_result, right_result)</div>
                </div>
                
                <h3>Pattern 2: Decrease and Conquer</h3>
                <div class="pattern-box">
                    <h4>Recognition:</h4>
                    <ul>
                        <li>Problem size reduced by constant in each step</li>
                        <li>Usually divide by 2 and solve only one subproblem</li>
                    </ul>
                    <h4>Examples:</h4>
                    <ul>
                        <li>Binary Search (only one half)</li>
                        <li>Fast Exponentiation</li>
                        <li>Euclidean GCD</li>
                    </ul>
                    <h4>Template:</h4>
<div class="code-block"><span class="keyword">def</span> <span class="function">decrease_conquer</span>(n):
    <span class="keyword">if</span> n <= base_size:
        <span class="keyword">return</span> solve_directly(n)
    
    <span class="comment"># Reduce problem size</span>
    smaller_problem = reduce(n)
    result = decrease_conquer(smaller_problem)
    
    <span class="keyword">return</span> expand(result, n)</div>
                </div>
                
                <h3>Pattern 3: Multi-way Division</h3>
                <div class="pattern-box">
                    <h4>Recognition:</h4>
                    <ul>
                        <li>Problem split into k > 2 subproblems</li>
                        <li>All subproblems must be solved</li>
                    </ul>
                    <h4>Examples:</h4>
                    <ul>
                        <li>Strassen's Matrix Multiplication (7 subproblems)</li>
                        <li>N-way Merge Sort</li>
                    </ul>
                    <h4>Template:</h4>
<div class="code-block"><span class="keyword">def</span> <span class="function">multi_way_divide</span>(problem, k):
    <span class="keyword">if</span> is_base_case(problem):
        <span class="keyword">return</span> solve_directly(problem)
    
    <span class="comment"># Divide into k parts</span>
    subproblems = divide_k_ways(problem, k)
    
    <span class="comment"># Solve all subproblems</span>
    results = [multi_way_divide(sub, k) <span class="keyword">for</span> sub <span class="keyword">in</span> subproblems]
    
    <span class="keyword">return</span> combine_k_results(results)</div>
                </div>
                
                <h3>Pattern 4: Transform and Conquer</h3>
                <div class="pattern-box">
                    <h4>Recognition:</h4>
                    <ul>
                        <li>Transform problem into simpler form</li>
                        <li>Solve transformed problem</li>
                        <li>Transform back to original</li>
                    </ul>
                    <h4>Examples:</h4>
                    <ul>
                        <li>Closest Pair (transform via sorting)</li>
                        <li>Convex Hull</li>
                    </ul>
                </div>
            </div>
            
            <!-- PROBLEMS -->
            <div class="section" id="problems">
                <h2>💻 LeetCode Problems</h2>
                
                <h3>🟢 Easy Problems</h3>
                <table>
                    <tr>
                        <th>Problem</th>
                        <th>LeetCode</th>
                        <th>Pattern</th>
                        <th>Key Idea</th>
                    </tr>
                    <tr>
                        <td><strong>Pow(x, n)</strong></td>
                        <td>LC 50</td>
                        <td>Decrease & Conquer</td>
                        <td>x^n = (x^(n/2))²</td>
                    </tr>
                    <tr>
                        <td><strong>Majority Element</strong></td>
                        <td>LC 169</td>
                        <td>Binary Division</td>
                        <td>Majority in whole = majority in half</td>
                    </tr>
                    <tr>
                        <td><strong>Sqrt(x)</strong></td>
                        <td>LC 69</td>
                        <td>Binary Search</td>
                        <td>Find largest i where i² ≤ x</td>
                    </tr>
                </table>
                
                <h3>🟡 Medium Problems</h3>
                <table>
                    <tr>
                        <th>Problem</th>
                        <th>LeetCode</th>
                        <th>Pattern</th>
                        <th>Key Idea</th>
                    </tr>
                    <tr>
                        <td><strong>Sort an Array</strong></td>
                        <td>LC 912</td>
                        <td>Merge/Quick Sort</td>
                        <td>Implement D&C sorting</td>
                    </tr>
                    <tr>
                        <td><strong>Kth Largest Element</strong></td>
                        <td>LC 215</td>
                        <td>Quick Select</td>
                        <td>Quick Sort partition</td>
                    </tr>
                    <tr>
                        <td><strong>Maximum Subarray</strong></td>
                        <td>LC 53</td>
                        <td>D&C or Kadane</td>
                        <td>Max in left, right, or crossing</td>
                    </tr>
                    <tr>
                        <td><strong>Different Ways to Add Parentheses</strong></td>
                        <td>LC 241</td>
                        <td>D&C</td>
                        <td>Split on operators</td>
                    </tr>
                    <tr>
                        <td><strong>Convert Sorted Array to BST</strong></td>
                        <td>LC 108</td>
                        <td>Binary Division</td>
                        <td>Middle element as root</td>
                    </tr>
                    <tr>
                        <td><strong>Merge k Sorted Lists</strong></td>
                        <td>LC 23</td>
                        <td>Multi-way Merge</td>
                        <td>Merge pairs recursively</td>
                    </tr>
                </table>
                
                <h3>🔴 Hard Problems</h3>
                <table>
                    <tr>
                        <th>Problem</th>
                        <th>LeetCode</th>
                        <th>Pattern</th>
                        <th>Key Idea</th>
                    </tr>
                    <tr>
                        <td><strong>Median of Two Sorted Arrays</strong></td>
                        <td>LC 4</td>
                        <td>Binary Search</td>
                        <td>Partition both arrays</td>
                    </tr>
                    <tr>
                        <td><strong>Count of Smaller After Self</strong></td>
                        <td>LC 315</td>
                        <td>Modified Merge Sort</td>
                        <td>Count inversions</td>
                    </tr>
                    <tr>
                        <td><strong>Reverse Pairs</strong></td>
                        <td>LC 493</td>
                        <td>Modified Merge Sort</td>
                        <td>Count pairs during merge</td>
                    </tr>
                </table>
                
                <h3>Problem-Solving Examples</h3>
                
                <h4>Example: Kth Largest Element (Quick Select)</h4>
<div class="code-block"><span class="keyword">def</span> <span class="function">find_kth_largest</span>(nums, k):
    <span class="comment">"""
    Find kth largest using Quick Select (D&C)
    Average: O(n), Worst: O(n²)
    """</span>
    k = len(nums) - k  <span class="comment"># Convert to kth smallest</span>
    
    <span class="keyword">def</span> <span class="function">quick_select</span>(left, right):
        pivot_idx = partition(nums, left, right)
        
        <span class="keyword">if</span> pivot_idx == k:
            <span class="keyword">return</span> nums[pivot_idx]
        <span class="keyword">elif</span> pivot_idx < k:
            <span class="keyword">return</span> quick_select(pivot_idx + 1, right)
        <span class="keyword">else</span>:
            <span class="keyword">return</span> quick_select(left, pivot_idx - 1)
    
    <span class="keyword">return</span> quick_select(0, len(nums) - 1)

<span class="keyword">def</span> <span class="function">partition</span>(nums, left, right):
    pivot = nums[right]
    i = left
    <span class="keyword">for</span> j <span class="keyword">in</span> range(left, right):
        <span class="keyword">if</span> nums[j] <= pivot:
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
    nums[i], nums[right] = nums[right], nums[i]
    <span class="keyword">return</span> i</div>

                <h4>Example: Convert Sorted Array to BST (LC 108)</h4>
<div class="code-block"><span class="keyword">def</span> <span class="function">sorted_array_to_bst</span>(nums):
    <span class="comment">"""
    Convert sorted array to balanced BST using D&C
    Time: O(n), Space: O(log n)
    """</span>
    <span class="keyword">if not</span> nums:
        <span class="keyword">return None</span>
    
    <span class="comment"># DIVIDE: Middle element as root</span>
    mid = len(nums) // 2
    root = TreeNode(nums[mid])
    
    <span class="comment"># CONQUER: Recursively build left and right subtrees</span>
    root.left = sorted_array_to_bst(nums[:mid])
    root.right = sorted_array_to_bst(nums[mid+1:])
    
    <span class="keyword">return</span> root</div>
            </div>
            
            <!-- TIPS -->
            <div class="section" id="tips">
                <h2>💡 Tips & Tricks</h2>
                
                <h3>🎯 When to Use Divide and Conquer</h3>
                <div class="success-box">
                    <h4>✅ Use D&C when:</h4>
                    <ul>
                        <li>Problem exhibits <strong>optimal substructure</strong></li>
                        <li>Subproblems are <strong>independent</strong> (no overlap)</li>
                        <li>Problem size can be <strong>reduced significantly</strong> (usually by half)</li>
                        <li>Combining solutions is <strong>efficient</strong></li>
                        <li>Problem has <strong>recursive structure</strong> (trees, arrays)</li>
                    </ul>
                </div>
                
                <h3>⚠️ Common Pitfalls</h3>
                <div class="warning-box">
                    <h4>Mistake 1: Inefficient Combine Step</h4>
                    <p>If combining takes O(n²), the benefit of dividing is lost!</p>
                    <p><strong>Solution:</strong> Ensure combine step is O(n) or better</p>
                    
                    <h4>Mistake 2: Overlapping Subproblems</h4>
                    <p>If subproblems overlap, use Dynamic Programming instead</p>
                    <p><strong>Example:</strong> Fibonacci with D&C is O(2^n), with DP is O(n)</p>
                    
                    <h4>Mistake 3: Not Handling Base Cases</h4>
                    <p>Always define clear base cases to stop recursion</p>
                    
                    <h4>Mistake 4: Incorrect Division</h4>
<div class="code-block"><span class="comment"># ❌ BAD - Creates copies</span>
left = arr[:mid]
right = arr[mid:]

<span class="comment"># ✅ GOOD - Use indices</span>
divide_conquer(arr, left, mid)
divide_conquer(arr, mid+1, right)</div>
                </div>
                
                <h3>🚀 Optimization Techniques</h3>
                
                <h4>1. Tail Recursion</h4>
<div class="code-block"><span class="comment"># Regular - Not tail recursive</span>
<span class="keyword">def</span> <span class="function">binary_search</span>(arr, target, left, right):
    <span class="keyword">if</span> left > right:
        <span class="keyword">return</span> -1
    mid = left + (right - left) // 2
    <span class="keyword">if</span> arr[mid] == target:
        <span class="keyword">return</span> mid
    <span class="keyword">elif</span> arr[mid] < target:
        <span class="keyword">return</span> binary_search(arr, target, mid+1, right)
    <span class="keyword">else</span>:
        <span class="keyword">return</span> binary_search(arr, target, left, mid-1)</div>

                <h4>2. Iterative Conversion</h4>
<div class="code-block"><!DOCTYPE html>
