╔════════════════════════════════════════════════════════════════════╗
║              🧠  RECURSION IN PYTHON – ONE PAGE VISUAL ROADMAP     ║
╚════════════════════════════════════════════════════════════════════╝

          ┌────────────────────────────────────────────┐
          │   ❓ WHAT IS RECURSION                     │
          │--------------------------------------------│
          │ A function that calls itself until a base  │
          │ condition (stopping point) is reached.     │
          └────────────────────────────────────────────┘
                         │
                         ▼
           ┌────────────────────────────┐
           │   STRUCTURE OF RECURSION   │
           │----------------------------│
           │ def func(x):               │
           │     if base_case: return x │
           │     smaller = func(x-1)    │
           │     combine(smaller)       │
           └────────────────────────────┘
                         │
                         ▼
   ┌────────────────────────────────────────────────────────────────┐
   │                 🧩 TYPES OF RECURSION                           │
   │────────────────────────────────────────────────────────────────│
   │  ➤ Direct        → func() calls itself                         │
   │  ➤ Indirect      → A→B→A calls                                 │
   │  ➤ Tail          → recursive call is the *last* step           │
   │  ➤ Non-tail      → does extra work after recursive call        │
   └────────────────────────────────────────────────────────────────┘
                         │
                         ▼
   ┌────────────────────────────────────────────────────────────────┐
   │              🧮 WHEN TO USE RECURSION                          │
   │────────────────────────────────────────────────────────────────│
   │ ✔ Divide & Conquer (MergeSort, QuickSort)                      │
   │ ✔ Tree Traversal (DFS, Preorder, etc.)                         │
   │ ✔ Graph Traversal (DFS)                                        │
   │ ✔ Backtracking (N-Queens, Sudoku)                              │
   │ ✔ Dynamic Programming (Memoization)                            │
   │ ✔ Nested / Hierarchical data (folders, XML, JSON)              │
   └────────────────────────────────────────────────────────────────┘
                         │
                         ▼
     ┌────────────────────────────────────────────┐
     │       🧩 THINKING RECURSIVELY              │
     │--------------------------------------------│
     │ 1️⃣ Identify smaller subproblem             │
     │ 2️⃣ Write base case                        │
     │ 3️⃣ Call recursively                       │
     │ 4️⃣ Combine results                        │
     │ Mnemonic: “Base → Break → Build”           │
     └────────────────────────────────────────────┘
                         │
                         ▼
   ┌────────────────────────────────────────────────────────────────┐
   │          🧠 CALL STACK VISUALIZATION                           │
   │────────────────────────────────────────────────────────────────│
   │ countdown(3) → print(3) → countdown(2) → print(2) → countdown(1) │
   │  ↑ stack grows → until base case → then unwinds back ↓          │
   │----------------------------------------------------------------│
   │ Every function call is PUSHED on stack and POPPED when done.   │
   └────────────────────────────────────────────────────────────────┘
                         │
                         ▼
   ┌────────────────────────────────────────────────────────────────┐
   │              ⚙️ REAL WORLD USE CASE                            │
   │────────────────────────────────────────────────────────────────│
   │ Traversing all folders in a directory:                         │
   │   traverse(path):                                              │
   │       for each subfolder → call traverse(subfolder)            │
   │       else print(file)                                         │
   └────────────────────────────────────────────────────────────────┘

╔════════════════════════════════════════════════════════════════════╗
║             🧩 WEEKLY PRACTICE PLAN (LEETCODE ROADMAP)             ║
╚════════════════════════════════════════════════════════════════════╝

🟢 WEEK 1 – FOUNDATIONS
────────────────────────
🎯 Concepts:
- Base case, recursive case, stack
- Factorial, sum of N, Fibonacci, power of two

🧠 Practice:
1️⃣ Factorial (basic recursion)
2️⃣ Fibonacci Number → [LeetCode #509]
3️⃣ Power of Two → [LeetCode #231]
4️⃣ Reverse String → [LeetCode #344]
5️⃣ Sum of digits

---

🟡 WEEK 2 – TREE & LINKED LIST RECURSION
────────────────────────────────────────
🎯 Concepts:
- Recursive traversal (DFS, preorder, inorder)
- Recursive node manipulation

🧠 Practice:
1️⃣ Same Tree → [LeetCode #100]
2️⃣ Symmetric Tree → [LeetCode #101]
3️⃣ Maximum Depth of Binary Tree → [LeetCode #104]
4️⃣ Merge Two Sorted Lists → [LeetCode #21]
5️⃣ Swap Nodes in Pairs → [LeetCode #24]

---

🔴 WEEK 3 – BACKTRACKING (ADVANCED RECURSION)
─────────────────────────────────────────────
🎯 Concepts:
- Explore all possibilities → backtrack on wrong path

🧠 Practice:
1️⃣ Subsets → [LeetCode #78]
2️⃣ Permutations → [LeetCode #46]
3️⃣ Combination Sum → [LeetCode #39]
4️⃣ Generate Parentheses → [LeetCode #22]
5️⃣ Letter Combinations of a Phone Number → [LeetCode #17]

---

🟣 WEEK 4 – DIVIDE & CONQUER + DP
──────────────────────────────────
🎯 Concepts:
- Split problem → solve subparts → merge results

🧠 Practice:
1️⃣ Merge Sort (custom implementation)
2️⃣ Quick Sort (custom implementation)
3️⃣ Climbing Stairs (DP with recursion) → [LeetCode #70]
4️⃣ Unique Paths → [LeetCode #62]
5️⃣ Minimum Path Sum → [LeetCode #64]

---

╔════════════════════════════════════════════════════════════════════╗
║  ⚡ TIPS FOR RECURSION MASTERY                                      ║
╚════════════════════════════════════════════════════════════════════╝
✅ Always define the BASE case first.  
✅ Don’t overthink the flow — trust the call stack.  
✅ Visualize recursion tree on paper.  
✅ Print intermediate results (debug with print).  
✅ Convert recursion → iteration later to check efficiency.  
✅ Practice patterns, not just problems.  
